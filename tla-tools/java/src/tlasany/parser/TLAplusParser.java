// Copyright (c) 2003 Compaq Corporation.  All rights reserved.
/* Generated By:JavaCC: Do not edit this line. TLAplusParser.java */
package tlasany.parser;

import org.zambrovski.tla.RuntimeConfiguration;

import tlasany.st.ParseTree;
import tlasany.st.TreeNode;

import tlasany.utilities.Vector;
import tlasany.utilities.Stack;
import tlasany.utilities.Assert;
import util.UniqueString;

public class TLAplusParser implements tlasany.st.SyntaxTreeConstants, ParseTree, TLAplusParserConstants {

  public String[] dependencies() {
    String[]deps = new String[ dependencyList.size() ];
    for (int lvi =0; lvi < deps.length; lvi++)
      deps[lvi] = ((UniqueString)dependencyList.elementAt(lvi)).toString();
    return deps;
  }
  public TreeNode rootNode() { return ParseTree; }
  public String moduleName() { return mn.toString(); }
  public tlasany.st.ParseErrors getErrors() { return PErrors; }

  public SyntaxTreeNode ParseTree;
  public Vector dependencyList = new Vector( 20 );

  private UniqueString mn = null;

  private boolean numberFlag = false;
  private boolean decimalFlag = false;

  private Operator FcnOp = Operators.getOperator( util.UniqueString.uniqueStringOf("[" ));
  private SyntaxTreeNode FairnessHook;

  private UniqueString At = util.UniqueString.uniqueStringOf("@");

  ParseErrors PErrors = new ParseErrors();

  private tlasany.parser.OperatorStack OperatorStack = new tlasany.parser.OperatorStack( PErrors );

  private BracketStack BStack;

  public boolean parse() {

    BStack = new BracketStack();
    BStack.newClass();
    BStack.registerInCurrentClass( BAND );
    BStack.registerInCurrentClass( AND );
    BStack.newClass();
    BStack.registerInCurrentClass( BOR );
    BStack.registerInCurrentClass( OR );
    BStack.newClass();
    BStack.registerInCurrentClass( PROOF );
    BStack.newClass();
    BStack.registerInCurrentClass( LBR );
    BStack.newClass();
    BStack.registerInCurrentClass( ASSUME );

    try {
      ParseTree = CompilationUnit();
    } catch( ParseException e ) {
      PErrors.push( new ParseError( msgStackToString(e) ) );
    } catch( TokenMgrError tme ) {
      // lexical error.
      String msg = tme.getMessage();
      int bl = jj_input_stream.getBeginLine() + 1;
      int el = jj_input_stream.getEndLine() + 1;
      // lexical error.
      if ( (msg.indexOf("EOF") != -1) && (bl != el) )  {
        PErrors.push(new ParseError("Lexical error: EOF reached, possibly open comment starting around line " + (bl-1) )) ;
      } else
        PErrors.push( new ParseError( msg  )) ;
//      PErrors.push( new ParseError( tme.getMessage() )) ;
    }
    if ( PErrors.empty() ) Assert.assertion( heirsIndex == 0 );
    else {
      tlasany.st.ParseError  list[] = PErrors.errors();
      for (int i = 0; i < list.length; i++ ) {
        RuntimeConfiguration.get().getOutStream().println( list[i].reportedError() );
//        RuntimeConfiguration.get().getOutStream().println( "+ " + list[i].defaultError() );
      }
    }
//   ParseTree.setNumberFlags( numberFlag, decimalFlag );
    return PErrors.empty();
  }

/*
  this is required to store temporarily information required by
  the semantic lookahead, as it doesn't have access to the variables
  of the production
*/
  private SyntaxTreeNode local;
  void registerTN( SyntaxTreeNode some) { local = some ; }
  boolean testTN() {
    return local.isKind(N_IdPrefix)
        && BStack.aboveReference( local.first().first().location[0] ) ;
  }

  private SyntaxTreeNode anchor = null;

// Lookahead mechanisms for definitions
  final private Token getNextPreviewToken(Token t) {
    if (t.next == null) t.next = token_source.getNextToken();
    return t.next;
  }

// borrowed from code generated by JavaCC.
  final private Token initPreviewToken() {
    return lookingAhead ? jj_scanpos : token;
  }

  private final void belchDEF() {
    Token previousT = initPreviewToken();
    Token currentT = getNextPreviewToken( previousT );
    previousT.next = null;  // <-- to break recursion 
    Token nextT = getNextPreviewToken( currentT );
    currentT.next = previousT;
    while ( nextT.kind != EOF && nextT.kind != THEOREM && nextT.kind != ASSUME&& nextT.kind != ASSUMPTION && nextT.kind != END_MODULE) {
      if ( currentT.kind == DEF ) {
        Token t = previousT;
        if        ( t.kind == RBR || t.kind == RSB ) {
          int depth = 1;
          while (t.next != null) {
            t = t.next;
            if ( (t.kind == LBR || t.kind == LSB) && depth == 1 ) break;
            if ( (t.kind == LBR || t.kind == LSB) && depth >  1 ) depth--;
            if ( (t.kind == RBR || t.kind == RSB) ) depth++;
          }
          t = t.next;
          if (t == null ) break;
          // we are positioned at first symbol before [ or ( : must be an identifier
        } else if ( t.kind == IDENTIFIER ) {
          Token identifier = t;
          if ( isOp( t.next )  && ! isPostfixOp( t.next ) ) {
            t = t.next;
            if ( t.next.kind == SUBSTITUTE )
               t = identifier; // skip back
            else if ( isInfixOp( t ) ) t = t.next;
            // else assume prefix
          }
        } else if (  isOp(t) ) { // assume postfix op, the parser will catch the error
          t = t.next;
        }
        Token i = new Token();
        i.kind = DEFBREAK; i.image = "Beginning of definition";
        i.beginLine = t.beginLine;
        i.beginColumn = t.beginColumn;
        i.endLine = t.endLine;
        i.endColumn = t.endColumn;
        i.next = t.next;
        t.next = i;
        break;
      } else {
        previousT = currentT;
        currentT = nextT;
        nextT = getNextPreviewToken( currentT );
        currentT.next = previousT;
      }
    }
    // reverse pointers.
    while (previousT != null ) {
      currentT.next = nextT;
      nextT = currentT;
      currentT = previousT;
      previousT = currentT.next;
    }
    // relink firstT
    currentT.next = nextT;
  }

//
  void skipOver( int l ) {
    while ( true ) {
      Token t = getToken(1);
      int k = t.kind;
      if ( (k == EOF) || (k ==ENDPROOF) || (t.beginColumn < l ) ) return;
      t = getNextToken();
    }
  }

boolean
ClosedStart( Token t ) {
  return   t.kind == IDENTIFIER
        || (t.kind >= op_57 && t.kind <= op_119)
        || t.kind == NUMBER_LITERAL
        || t.kind == LBR
        || t.kind == LSB
        || t.kind == LAB
        || t.kind == LBC
        || t.kind == LWB
        || t.kind == STRING_LITERAL
        || t.kind == WF
        || t.kind == SF;
}

boolean
isOp( Token t ) {
  return t.kind >= op_57 && t.kind <= op_119;
}

boolean isInfixOp( Token t ) {
  return t.kind >= op_1 && t.kind <= op_119;
}

boolean isPostfixOp( Token t ) {
  return t.kind >= op_57 && t.kind <= op_70;
}

boolean isPrefixOp( Token t ) {
  return t.kind >= op_26 && t.kind <= op_116;
}

// global variable follows !!! Make sure it is set everywhere as required
Operator lastOp;

  boolean isGenOp(SyntaxTreeNode tn) { /* has to be of the form prefix, opsym */
    int kind = tn.getKind();
    if ( kind == N_GenPrefixOp
      || kind == N_GenNonExpPrefixOp
      || kind == N_GenInfixOp
      || kind == N_GenPostfixOp
      || kind == N_FcnAppl )
       return true;
    else
      return false;
  }

  boolean IsNotExpression () {
    Token t = initPreviewToken();
    int k = t.kind;
    if ( k == US || k == LOCAL || k == VARIABLE || k == PARAMETER || k == INSTANCE || k == CONSTANT || k == STATE || k == ACTION || k == TEMPORAL ) return true;
    else {
      t = getNextPreviewToken(t); k = t.kind;
      if ( k == US || k == DEF || k  == LSB )
        return true;
      else if (k == LBR) {
        int depth = 1;
        Token nt = getNextPreviewToken(t);
        while (true) {
          t = nt; nt = getNextPreviewToken(t); k = t.kind;
          if ( k == RBR ) {
             if ( depth == 1 )
               if ( nt.kind == DEF ) return true;
               else return false;
             else
                depth--;
          } else
          if ( k == LBR ) { depth++;
          } else
          if ( k == EOF ) return false;
        }
      }
    }
    return false;
  }

  boolean isFieldNameToken( Token t ) {
    if ( (t.kind >= ACTION && t.kind <= EXCEPT)
       ||(t.kind == EXTENDS)
       ||(t.kind >= INSTANCE && t.kind <= PARAMETER)
       ||(t.kind >= PREDICATE && t.kind <= SF)
       ||(t.kind == STATE)
       ||(t.kind >= TEMPORAL && t.kind <= WITH)
       ||(t.kind == US)
       ||(t.kind >= op_112 && t.kind <= op_116)
       )
       return true;
     else
       return false;
  }

// predicate used in lookahead to discriminate between the Case Separator and
// the box operator. Returns true if it is most likely not the separator.
// This is a weak mechanism.
  boolean boxDisc() {
    Token t = getToken(1);
    if ( t.kind == CASESEP )
      return OperatorStack.preInEmptyTop();
    else
      return true;
  }

  boolean caseSep() {
    Token t = getToken(1);
    return ( t.kind == CASESEP );
  }

  boolean matchFcnConst () {
    Token t = initPreviewToken();
    t = getNextPreviewToken( t );
   if (t.kind == LAB) {
      int count = 1;
      while (count != 0 ) {
        t = getNextPreviewToken( t );
        if (t.kind == LAB) count++;
        if (t.kind == RAB) count--;
        if (t.kind == EOF) return false;
      }
      t = getNextPreviewToken( t );
      return (t.kind == IN );
    } else
    if (t.kind == IDENTIFIER) {
      t = getNextPreviewToken( t );
      while ( t.kind == COMMA ) {
        t = getNextPreviewToken( t );
        if (t.kind != IDENTIFIER) return false;
        t = getNextPreviewToken( t );
      }
      return (t.kind == IN );
    } else
      return false;
  }

  int numberFromStep( String step ) {
    int top = step.indexOf('>');
    return Integer.parseInt( step.substring( 1, top ) );
  }
//
  Object msgStack[] = new Object[ 512 ];
  int msgStackMaxSize = 512;
  int msgStackCurrentSize = 0;

  private final void pushMsg( String s, Token t ) {
    if ( msgStackCurrentSize == msgStackMaxSize) {
      Object neo[] = new Object[ 2 * msgStackMaxSize ];
      System.arraycopy(msgStack, 0, neo, 0, msgStackMaxSize);
      msgStack = neo;
      msgStackMaxSize *= 2;
    }
    msgStack [ msgStackCurrentSize   ] = s;
    msgStack [ msgStackCurrentSize+1 ] = t;
    msgStackCurrentSize +=2;
  }

  private final void popMsg() {
    msgStackCurrentSize -=2;
  }

  private String expecting = "nothing";

  private final String msgStackToString(ParseException e) {
    StringBuffer msg;
    String name = " *unknown* (error occurred before module header)";
    if (mn != null) name = mn.toString();

    msg = new StringBuffer("***Parse Error***\n");
    if ( expecting != emptyString ) {
      msg.append("Was expecting \"");
      msg.append( expecting );
      msg.append("\"\n");
    }

    msg.append(e.getShortMessage());
//    msg.append(" while parsing ");
//    msg.append(name);
//
//    msg.append(".\nResidual stack trace follows:\n");

    msg.append("\n\nResidual stack trace follows:\n");
    int last = msgStackCurrentSize - 10;
    if (last < 0 ) last = 0;
    for ( int lvi = msgStackCurrentSize; lvi > last; lvi -=2 ) {
      msg.append( (String) msgStack[lvi -2 ] );
      msg.append(" starting at line ");
      Token t =  (Token) msgStack[lvi - 1 ];
      msg.append( t.beginLine );
      msg.append(", column ");
      msg.append( t.beginColumn );
      msg.append(".\n");
    }
    return msg.toString();
  }

//
  private SyntaxTreeNode heirsTable[] = new SyntaxTreeNode[ 512 ];
  private int heirsSize = 512;
  private int heirsIndex = 0;

  private final void addHeir( SyntaxTreeNode sn ) {
    if ( heirsIndex == heirsSize ) {
      SyntaxTreeNode nh[] = new SyntaxTreeNode[ heirsSize + 512 ];
      System.arraycopy( heirsTable, 0, nh, 0, heirsSize );
      heirsSize += 512;
      heirsTable = nh;
    }
    heirsTable[ heirsIndex ] = sn; heirsIndex++;
  }

  private final SyntaxTreeNode[] getLastHeirs() {
    int lvi = heirsIndex - 1;
    while (heirsTable[ lvi ] != null ) lvi--;
    int as = heirsIndex - lvi - 1;
    if (as == 0)
      return null;
    else {
      SyntaxTreeNode ts[] = new SyntaxTreeNode[ as ];
      System.arraycopy( heirsTable, lvi + 1, ts, 0, as);
      heirsIndex = lvi + 1;
      return ts;
    }
  }

  private final boolean popHeir() {
    return heirsTable[ --heirsIndex ] == null;
  }

  private String emptyString = "";

  private final void bpa( String s) { // Beginning of Production Actions 
    addHeir( null );
if (RuntimeConfiguration.get().doTLAStackTrace()) RuntimeConfiguration.get().getOutStream().println("Beginning " + s);
    pushMsg( s, getToken(1) );
    expecting = emptyString;
  }

  private final void epa() {
    popMsg();
if (RuntimeConfiguration.get().doTLAStackTrace()) RuntimeConfiguration.get().getOutStream().println("Ending " + msgStack [ msgStackCurrentSize   ]);
    Assert.assertion( popHeir() );
    expecting = emptyString;
  }
//

  Stack internals = new Stack();

  private final void addDependency( UniqueString s ) {
    int lvi = internals.search( s );
    if ( lvi < 0 )
      dependencyList.addElement( s );
  }

/* beginning of the grammar productions */
  final public Token PrefixOpToken() throws ParseException {
  Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case op_26:
      t = jj_consume_token(op_26);
      break;
    case op_29:
      t = jj_consume_token(op_29);
      break;
    case op_58:
      t = jj_consume_token(op_58);
      break;
    case CASESEP:
      t = jj_consume_token(CASESEP);
      break;
    case op_61:
      t = jj_consume_token(op_61);
      break;
    case op_112:
      t = jj_consume_token(op_112);
      break;
    case op_113:
      t = jj_consume_token(op_113);
      break;
    case op_114:
      t = jj_consume_token(op_114);
      break;
    case op_115:
      t = jj_consume_token(op_115);
      break;
    case op_116:
      t = jj_consume_token(op_116);
      break;
    default:
      jj_la1[0] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return t;}
    throw new Error("Missing return statement in function");
  }

  final public Token NEPrefixOpToken() throws ParseException {
  Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case op_26:
      t = jj_consume_token(op_26);
      break;
    case op_29:
      t = jj_consume_token(op_29);
      break;
    case op_58:
      t = jj_consume_token(op_58);
      break;
    case CASESEP:
      t = jj_consume_token(CASESEP);
      break;
    case op_61:
      t = jj_consume_token(op_61);
      break;
    case op_76:
      t = jj_consume_token(op_76);
      break;
    case op_112:
      t = jj_consume_token(op_112);
      break;
    case op_113:
      t = jj_consume_token(op_113);
      break;
    case op_114:
      t = jj_consume_token(op_114);
      break;
    case op_115:
      t = jj_consume_token(op_115);
      break;
    case op_116:
      t = jj_consume_token(op_116);
      break;
    default:
      jj_la1[1] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return t;}
    throw new Error("Missing return statement in function");
  }

  final public Token InfixOpToken() throws ParseException {
  Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case op_1:
      t = jj_consume_token(op_1);
      break;
    case AND:
      t = jj_consume_token(AND);
      break;
    case op_3:
      t = jj_consume_token(op_3);
      break;
    case op_4:
      t = jj_consume_token(op_4);
      break;
    case OR:
      t = jj_consume_token(OR);
      break;
    case op_6:
      t = jj_consume_token(op_6);
      break;
    case op_7:
      t = jj_consume_token(op_7);
      break;
    case op_8:
      t = jj_consume_token(op_8);
      break;
    case op_9:
      t = jj_consume_token(op_9);
      break;
    case op_10:
      t = jj_consume_token(op_10);
      break;
    case op_11:
      t = jj_consume_token(op_11);
      break;
    case op_12:
      t = jj_consume_token(op_12);
      break;
    case op_13:
      t = jj_consume_token(op_13);
      break;
    case op_14:
      t = jj_consume_token(op_14);
      break;
    case op_15:
      t = jj_consume_token(op_15);
      break;
    case op_16:
      t = jj_consume_token(op_16);
      break;
    case op_17:
      t = jj_consume_token(op_17);
      break;
    case op_18:
      t = jj_consume_token(op_18);
      break;
    case op_19:
      t = jj_consume_token(op_19);
      break;
    case IN:
      t = jj_consume_token(IN);
      break;
    case op_21:
      t = jj_consume_token(op_21);
      break;
    case op_22:
      t = jj_consume_token(op_22);
      break;
    case op_23:
      t = jj_consume_token(op_23);
      break;
    case op_24:
      t = jj_consume_token(op_24);
      break;
    case op_25:
      t = jj_consume_token(op_25);
      break;
    case op_27:
      t = jj_consume_token(op_27);
      break;
    case op_30:
      t = jj_consume_token(op_30);
      break;
    case op_31:
      t = jj_consume_token(op_31);
      break;
    case op_32:
      t = jj_consume_token(op_32);
      break;
    case op_33:
      t = jj_consume_token(op_33);
      break;
    case op_34:
      t = jj_consume_token(op_34);
      break;
    case op_35:
      t = jj_consume_token(op_35);
      break;
    case op_36:
      t = jj_consume_token(op_36);
      break;
    case op_37:
      t = jj_consume_token(op_37);
      break;
    case op_38:
      t = jj_consume_token(op_38);
      break;
    case op_39:
      t = jj_consume_token(op_39);
      break;
    case op_40:
      t = jj_consume_token(op_40);
      break;
    case op_41:
      t = jj_consume_token(op_41);
      break;
    case op_42:
      t = jj_consume_token(op_42);
      break;
    case op_43:
      t = jj_consume_token(op_43);
      break;
    case op_44:
      t = jj_consume_token(op_44);
      break;
    case op_45:
      t = jj_consume_token(op_45);
      break;
    case op_46:
      t = jj_consume_token(op_46);
      break;
    case op_47:
      t = jj_consume_token(op_47);
      break;
    case op_48:
      t = jj_consume_token(op_48);
      break;
    case op_49:
      t = jj_consume_token(op_49);
      break;
    case op_50:
      t = jj_consume_token(op_50);
      break;
    case op_51:
      t = jj_consume_token(op_51);
      break;
    case op_52:
      t = jj_consume_token(op_52);
      break;
    case op_53:
      t = jj_consume_token(op_53);
      break;
    case op_54:
      t = jj_consume_token(op_54);
      break;
    case op_55:
      t = jj_consume_token(op_55);
      break;
    case op_56:
      t = jj_consume_token(op_56);
      break;
    case op_59:
      t = jj_consume_token(op_59);
      break;
    case op_62:
      t = jj_consume_token(op_62);
      break;
    case op_63:
      t = jj_consume_token(op_63);
      break;
    case op_64:
      t = jj_consume_token(op_64);
      break;
    case EQUALS:
      t = jj_consume_token(EQUALS);
      break;
    case op_66:
      t = jj_consume_token(op_66);
      break;
    case op_67:
      t = jj_consume_token(op_67);
      break;
    case op_71:
      t = jj_consume_token(op_71);
      break;
    case op_72:
      t = jj_consume_token(op_72);
      break;
    case op_73:
      t = jj_consume_token(op_73);
      break;
    case op_74:
      t = jj_consume_token(op_74);
      break;
    case op_75:
      t = jj_consume_token(op_75);
      break;
    case op_77:
      t = jj_consume_token(op_77);
      break;
    case op_78:
      t = jj_consume_token(op_78);
      break;
    case op_79:
      t = jj_consume_token(op_79);
      break;
    case op_80:
      t = jj_consume_token(op_80);
      break;
    case op_81:
      t = jj_consume_token(op_81);
      break;
    case op_82:
      t = jj_consume_token(op_82);
      break;
    case op_83:
      t = jj_consume_token(op_83);
      break;
    case op_84:
      t = jj_consume_token(op_84);
      break;
    case op_85:
      t = jj_consume_token(op_85);
      break;
    case op_86:
      t = jj_consume_token(op_86);
      break;
    case op_87:
      t = jj_consume_token(op_87);
      break;
    case op_88:
      t = jj_consume_token(op_88);
      break;
    case op_89:
      t = jj_consume_token(op_89);
      break;
    case op_90:
      t = jj_consume_token(op_90);
      break;
    case op_91:
      t = jj_consume_token(op_91);
      break;
    case op_92:
      t = jj_consume_token(op_92);
      break;
    case op_93:
      t = jj_consume_token(op_93);
      break;
    case op_94:
      t = jj_consume_token(op_94);
      break;
    case op_95:
      t = jj_consume_token(op_95);
      break;
    case op_96:
      t = jj_consume_token(op_96);
      break;
    case op_97:
      t = jj_consume_token(op_97);
      break;
    case op_98:
      t = jj_consume_token(op_98);
      break;
    case op_100:
      t = jj_consume_token(op_100);
      break;
    case op_101:
      t = jj_consume_token(op_101);
      break;
    case op_102:
      t = jj_consume_token(op_102);
      break;
    case op_103:
      t = jj_consume_token(op_103);
      break;
    case op_104:
      t = jj_consume_token(op_104);
      break;
    case op_105:
      t = jj_consume_token(op_105);
      break;
    case op_106:
      t = jj_consume_token(op_106);
      break;
    case op_107:
      t = jj_consume_token(op_107);
      break;
    case op_108:
      t = jj_consume_token(op_108);
      break;
    case op_109:
      t = jj_consume_token(op_109);
      break;
    case op_110:
      t = jj_consume_token(op_110);
      break;
    case op_111:
      t = jj_consume_token(op_111);
      break;
    case op_117:
      t = jj_consume_token(op_117);
      break;
    case op_118:
      t = jj_consume_token(op_118);
      break;
    case op_119:
      t = jj_consume_token(op_119);
      break;
    default:
      jj_la1[2] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return t;}
    throw new Error("Missing return statement in function");
  }

  final public Token PostfixOpToken() throws ParseException {
Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case op_57:
      t = jj_consume_token(op_57);
      break;
    case op_68:
      t = jj_consume_token(op_68);
      break;
    case op_69:
      t = jj_consume_token(op_69);
      break;
    case op_70:
      t = jj_consume_token(op_70);
      break;
    default:
      jj_la1[3] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return t;}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode CompilationUnit() throws ParseException {
  SyntaxTreeNode tempASTN;
  belchDEF();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BEGIN_PRAGMA:
      Prelude();
      break;
    default:
      jj_la1[4] = jj_gen;
      ;
    }
    tempASTN = Module();
                        token_source.SwitchTo(0);
    {if (true) return tempASTN;}
    throw new Error("Missing return statement in function");
  }

/* SwitchTo is used to reset the state of the tokenizer */
  final public void Prelude() throws ParseException {
    jj_consume_token(BEGIN_PRAGMA);
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NUMBER:
      case IDENTIFIER:
        ;
        break;
      default:
        jj_la1[5] = jj_gen;
        break label_1;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NUMBER:
        jj_consume_token(NUMBER);
        break;
      case IDENTIFIER:
        jj_consume_token(IDENTIFIER);
        break;
      default:
        jj_la1[6] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

  final public SyntaxTreeNode Module() throws ParseException {
  Token t;
  SyntaxTreeNode lSTN[] = new SyntaxTreeNode[ 4 ];
  bpa( "Module definition" );
  internals.push( null );
  Object pop = null;
  expecting = "---- MODULE";
    lSTN[0] = BeginModule();
  expecting = "EXTENDS clause or module body";
    lSTN[1] = Extends();
  expecting = "Module body";
    lSTN[2] = Body();
  expecting = "==== or more Module body";
    lSTN[3] = EndModule();
  do { pop = internals.pop(); } while (pop != null );
  internals.push( lSTN[0].zero[1].image );
  epa(); {if (true) return new SyntaxTreeNode( mn, N_Module, lSTN );}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode BeginModule() throws ParseException {
  SyntaxTreeNode lSTN[] = new SyntaxTreeNode[3];
  Token t;
  bpa( "Begin module" );
  expecting = "---- MODULE (beginning of module)";
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case _BM0:
      t = jj_consume_token(_BM0);
      break;
    case _BM1:
      t = jj_consume_token(_BM1);
      break;
    case _BM2:
      t = jj_consume_token(_BM2);
      break;
    default:
      jj_la1[7] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      lSTN[0] =  new SyntaxTreeNode(mn, t);
  expecting = "Identifier";
  t = getToken(1);
  if (isFieldNameToken( t )) t.kind = IDENTIFIER;
    lSTN[1] = Identifier();
    if ( mn == null ) mn = lSTN[1].image;
    expecting = "----";
    t = jj_consume_token(SEPARATOR);
                      lSTN[2] =  new SyntaxTreeNode(mn, t );
    epa(); {if (true) return new SyntaxTreeNode( mn, N_BeginModule, lSTN );}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode EndModule() throws ParseException {
  SyntaxTreeNode lSTN[] = new SyntaxTreeNode[1];
  Token t;
    t = jj_consume_token(END_MODULE);
    lSTN[0] = new SyntaxTreeNode(mn, t);
    {if (true) return new SyntaxTreeNode(mn, N_EndModule, lSTN );}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode Extends() throws ParseException {
  SyntaxTreeNode tn;
  Token t;
  bpa( "Extends" );
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EXTENDS:
      t = jj_consume_token(EXTENDS);
                        addHeir( new SyntaxTreeNode(mn, t));
  expecting = "Identifier";
  t = getToken(1);
  if (isFieldNameToken( t )) t.kind = IDENTIFIER;
      tn = Identifier();
                      addDependency( tn.image ); addHeir( tn );
  expecting = "comma or module body";
      label_2:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[8] = jj_gen;
          break label_2;
        }
        t = jj_consume_token(COMMA);
                       addHeir( new SyntaxTreeNode(mn, t) );
  expecting = "Identifier";
  t = getToken(1);
  if (isFieldNameToken( t )) t.kind = IDENTIFIER;
        tn = Identifier();
                        addDependency( tn.image ); addHeir( tn );
      }
      break;
    default:
      jj_la1[9] = jj_gen;
      ;
    }
    SyntaxTreeNode sn[] = getLastHeirs();
    epa(); {if (true) return new SyntaxTreeNode( mn, N_Extends, sn );}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode Body() throws ParseException {
  SyntaxTreeNode tn, sn[];
  Token t;
  bpa("Module body");
  expecting = "LOCAL, INSTANCE, PROOF, ASSUMPTION, THEOREM, declaration or definition";
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case _BM1:
      case _BM2:
      case _BM0:
      case SEPARATOR:
      case ACTION:
      case ASSUME:
      case ASSUMPTION:
      case CONSTANT:
      case INSTANCE:
      case LOCAL:
      case PARAMETER:
      case PREDICATE:
      case PROPOSITION:
      case PROOF:
      case STATE:
      case TEMPORAL:
      case THEOREM:
      case TRANSITION:
      case VARIABLE:
      case DEFBREAK:
        ;
        break;
      default:
        jj_la1[10] = jj_gen;
        break label_3;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case SEPARATOR:
        t = jj_consume_token(SEPARATOR);
                        tn = new SyntaxTreeNode(mn, t);
        break;
      case VARIABLE:
        tn = VariableDeclaration();
        break;
      case ACTION:
      case CONSTANT:
      case PARAMETER:
      case PREDICATE:
      case STATE:
      case TEMPORAL:
      case TRANSITION:
        tn = ParamDeclaration();
        break;
      default:
        jj_la1[11] = jj_gen;
        if (jj_2_1(2)) {
          tn = OperatorOrFunctionDefinition();
        } else if (jj_2_2(2)) {
          tn = Instance();
        } else if (jj_2_3(2)) {
          tn = Theorem();
        } else if (jj_2_4(2)) {
          tn = Assumption();
        } else {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case PROOF:
            tn = Proof();
            break;
          case _BM1:
          case _BM2:
          case _BM0:
            tn = Module();
                                      belchDEF();
            break;
          default:
            jj_la1[12] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
      }
      addHeir(tn);
    }
    sn = getLastHeirs(); epa();
    {if (true) return new SyntaxTreeNode(mn, N_Body, sn );}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode VariableDeclaration() throws ParseException {
  SyntaxTreeNode tn, sn[];
  Token t;
  SyntaxTreeNode lSTN[] = new SyntaxTreeNode[1];
  bpa( "variable declaration" );
    t = jj_consume_token(VARIABLE);
                       lSTN[0] = new SyntaxTreeNode( mn, t);
  expecting = "Identifier";
    tn = Identifier();
                      addHeir( tn );
  expecting = "comma or module body";
    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[13] = jj_gen;
        break label_4;
      }
      t = jj_consume_token(COMMA);
                       addHeir( new SyntaxTreeNode( mn, t) ) ;
  expecting = "Identifier";
      tn = Identifier();
                        addHeir( tn );
    }
    sn = getLastHeirs();
    epa(); {if (true) return new SyntaxTreeNode(mn, N_VariableDeclaration, lSTN, sn );}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode ParamDeclaration() throws ParseException {
  SyntaxTreeNode tn, sn[];
  Token t;
  bpa("Parameter declaration");
  expecting = "CONSTANT or PREDICATE or ACTION or TEMPORAL or PARAMETER or STATE";
    tn = ParamSubDecl();
                         addHeir(tn);
 expecting = "Identifier, operator or _";
    tn = ConstantDeclarationItems();
                                    addHeir(tn);
 expecting = ",";
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[14] = jj_gen;
        break label_5;
      }
      t = jj_consume_token(COMMA);
                       addHeir( new SyntaxTreeNode(mn, t) ) ;
 expecting = "Identifier, operator or _";
      tn = ConstantDeclarationItems();
                                      addHeir(tn);
    }
    sn = getLastHeirs();
    epa(); {if (true) return new SyntaxTreeNode(mn, N_ParamDeclaration, sn );}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode ParamSubDecl() throws ParseException {
  SyntaxTreeNode tn, sn[];
  Token t, u;
  bpa("Parameter declaration item");
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CONSTANT:
      t = jj_consume_token(CONSTANT);
     sn = new SyntaxTreeNode[1]; sn[0] = new SyntaxTreeNode(mn, t);
     tn = new SyntaxTreeNode(mn, N_ConsDecl, sn );
      break;
    case PREDICATE:
      t = jj_consume_token(PREDICATE);
     sn = new SyntaxTreeNode[1]; sn[0] = new SyntaxTreeNode(mn, t);
     tn = new SyntaxTreeNode(mn, N_SFcnDecl, sn );
      break;
    case ACTION:
      t = jj_consume_token(ACTION);
     sn = new SyntaxTreeNode[1]; sn[0] = new SyntaxTreeNode(mn, t);
     tn = new SyntaxTreeNode(mn, N_ActDecl, sn );
      break;
    case TEMPORAL:
      t = jj_consume_token(TEMPORAL);
     sn = new SyntaxTreeNode[1]; sn[0] = new SyntaxTreeNode(mn, t);
     tn = new SyntaxTreeNode(mn, N_TempDecl, sn );
      break;
    case PARAMETER:
      t = jj_consume_token(PARAMETER);
     sn = new SyntaxTreeNode[1]; sn[0] = new SyntaxTreeNode(mn, t);
     tn = new SyntaxTreeNode(mn, N_ParamDecl, sn );
      break;
    case STATE:
    case TRANSITION:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STATE:
        t = jj_consume_token(STATE);
       sn = new SyntaxTreeNode[2];
       sn[0] = new SyntaxTreeNode(mn, t);
       tn = new SyntaxTreeNode(mn, N_SFcnDecl, sn );
        break;
      case TRANSITION:
        t = jj_consume_token(TRANSITION);
       sn = new SyntaxTreeNode[2];
       sn[0] = new SyntaxTreeNode(mn, t);
       tn = new SyntaxTreeNode(mn, N_ActDecl, sn );
        break;
      default:
        jj_la1[15] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      t = jj_consume_token(FUNCTION);
                        sn[1] = new SyntaxTreeNode(mn, t);
      break;
    default:
      jj_la1[16] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    epa();
    {if (true) return tn;}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode ConstantDeclarationItems() throws ParseException {
  SyntaxTreeNode tn, sn[];
  int kind;
  Token t;
  bpa( "Constant declaration items");
  expecting = "Identifier, _ or prefix op";
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
      tn = Identifier();
                      addHeir( tn ); kind = N_IdentDecl;
expecting  = "(, comma or Module Body";
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBR:
        t = jj_consume_token(LBR);
                  addHeir( new SyntaxTreeNode( mn, t) ) ;
expecting = "_";
        t = jj_consume_token(US);
                  addHeir( new SyntaxTreeNode( mn, t) ) ;
expecting = "comma or )";
        label_6:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case COMMA:
            ;
            break;
          default:
            jj_la1[17] = jj_gen;
            break label_6;
          }
          t = jj_consume_token(COMMA);
                      addHeir( new SyntaxTreeNode( mn, t) ) ;
expecting = "_";
          t = jj_consume_token(US);
                      addHeir( new SyntaxTreeNode( mn, t) ) ;
expecting = "comma or )";
        }
        t = jj_consume_token(RBR);
                  addHeir( new SyntaxTreeNode( mn, t) ) ;
        break;
      default:
        jj_la1[18] = jj_gen;
        ;
      }
      break;
    case op_76:
    case op_26:
    case op_29:
    case op_58:
    case CASESEP:
    case op_61:
    case op_112:
    case op_113:
    case op_114:
    case op_115:
    case op_116:
      // LOOKAHEAD( <OpSymbol>, { isPrefixDeclOp( getToken(1) )  } )
          tn = NonExpPrefixOp();
expecting = "_";
      kind = N_PrefixDecl; addHeir( tn );
      t = jj_consume_token(US);
               addHeir( new SyntaxTreeNode( mn, t) ) ;
      break;
    case US:
      t = jj_consume_token(US);
expecting = "prefix or postfix operator";
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case op_1:
      case AND:
      case op_3:
      case op_4:
      case OR:
      case op_6:
      case op_7:
      case op_8:
      case op_9:
      case op_10:
      case op_11:
      case op_12:
      case op_13:
      case op_14:
      case op_15:
      case op_16:
      case op_17:
      case op_18:
      case op_19:
      case IN:
      case op_21:
      case op_22:
      case op_23:
      case op_24:
      case op_25:
      case op_27:
      case op_30:
      case op_31:
      case op_32:
      case op_33:
      case op_34:
      case op_35:
      case op_36:
      case op_37:
      case op_38:
      case op_39:
      case op_40:
      case op_41:
      case op_42:
      case op_43:
      case op_44:
      case op_45:
      case op_46:
      case op_47:
      case op_48:
      case op_49:
      case op_50:
      case op_51:
      case op_52:
      case op_53:
      case op_54:
      case op_55:
      case op_56:
      case op_59:
      case op_62:
      case op_63:
      case op_64:
      case EQUALS:
      case op_66:
      case op_67:
      case op_71:
      case op_72:
      case op_73:
      case op_74:
      case op_75:
      case op_77:
      case op_78:
      case op_79:
      case op_80:
      case op_81:
      case op_82:
      case op_83:
      case op_84:
      case op_85:
      case op_86:
      case op_87:
      case op_88:
      case op_89:
      case op_90:
      case op_91:
      case op_92:
      case op_93:
      case op_94:
      case op_95:
      case op_96:
      case op_97:
      case op_98:
      case op_100:
      case op_101:
      case op_102:
      case op_103:
      case op_104:
      case op_105:
      case op_106:
      case op_107:
      case op_108:
      case op_109:
      case op_110:
      case op_111:
      case op_117:
      case op_118:
      case op_119:
        tn = InfixOp();
expecting = "_";
        kind = N_InfixDecl;
        addHeir( new SyntaxTreeNode( mn, t) );
        addHeir(tn);
        t = jj_consume_token(US);
                   addHeir( new SyntaxTreeNode( mn, t) ) ;
        break;
      case op_57:
      case op_68:
      case op_69:
      case op_70:
        tn = PostfixOp();
        kind = N_PostfixDecl;
        addHeir( new SyntaxTreeNode( mn, t) );
        addHeir(tn);
        break;
      default:
        jj_la1[19] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[20] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    sn = getLastHeirs(); epa();
    {if (true) return new SyntaxTreeNode( mn, kind, sn);}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode OperatorOrFunctionDefinition() throws ParseException {
  SyntaxTreeNode tn;
  SyntaxTreeNode zn = null;
  bpa("Definition");
  int kind = 0;
  String n;
  Token t;
  expecting = "LOCAL, Identifier or Operator Symbol";
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LOCAL:
      t = jj_consume_token(LOCAL);
                  zn = new SyntaxTreeNode( mn, t);
      break;
    default:
      jj_la1[21] = jj_gen;
      ;
    }
    t = jj_consume_token(DEFBREAK);
  expecting = "LOCAL, Identifier or Operator Symbol";
    if (jj_2_6(2147483647)) {
      /* recognize function */
              tn = Identifier();
                            addHeir( tn );  kind = N_FunctionDefinition;
expecting = "[";
      t = jj_consume_token(LSB);
          addHeir( new SyntaxTreeNode(mn, t) );
expecting = "Identifier";
      tn = QuantBound();
                            addHeir( tn );
expecting = "COMMA or ]";
      label_7:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[22] = jj_gen;
          break label_7;
        }
        t = jj_consume_token(COMMA);
                        addHeir( new SyntaxTreeNode(mn, t) );
expecting = "Identifier";
        tn = QuantBound();
                              addHeir( tn );
      }
      t = jj_consume_token(RSB);
expecting = "==";
          addHeir( new SyntaxTreeNode(mn, t) );
      t = jj_consume_token(DEF);
                     belchDEF(); addHeir( new SyntaxTreeNode(mn, t) );
expecting = "Expression";
      tn = Expression();
                            addHeir( tn );
    } else if (jj_2_7(2147483647)) {
      tn = PostfixLHS();
                             addHeir( tn );
expecting = "==";
      t = jj_consume_token(DEF);
                     belchDEF(); kind = N_OperatorDefinition;
          addHeir( new SyntaxTreeNode(mn, t) );
expecting = "Expression";
      tn = Expression();
                            addHeir( tn );
    } else if (jj_2_8(2147483647)) {
      tn = InfixLHS();
                           addHeir( tn );
expecting = "==";
      t = jj_consume_token(DEF);
                     belchDEF();  kind = N_OperatorDefinition;
          addHeir( new SyntaxTreeNode(mn, t) );
expecting = "Expression";
      tn = Expression();
                            addHeir( tn );
    } else if (jj_2_9(2147483647)) {
      /* recognize operator OR module instance */
              tn = IdentLHS();
                          addHeir( tn );
expecting = "==";
      t = jj_consume_token(DEF);
                     belchDEF(); addHeir( new SyntaxTreeNode(mn, t) );
expecting = "Expression or Instance";
      if (jj_2_5(1)) {
        tn = Expression();
                              kind = N_OperatorDefinition;
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case INSTANCE:
          tn = Instantiation();
                                   kind = N_ModuleDefinition;
          break;
        default:
          jj_la1[23] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
            addHeir( tn );
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case op_76:
      case op_26:
      case op_29:
      case op_58:
      case CASESEP:
      case op_61:
      case op_112:
      case op_113:
      case op_114:
      case op_115:
      case op_116:
        tn = PrefixLHS();
                         addHeir( tn );
expecting = "==";
        t = jj_consume_token(DEF);
                   belchDEF();
        kind = N_OperatorDefinition;
        addHeir( new SyntaxTreeNode(mn, t) );
expecting = "Expression";
        tn = Expression();
                          addHeir( tn );
        break;
      default:
        jj_la1[24] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    SyntaxTreeNode sn[] = getLastHeirs();
    epa(); {if (true) return new SyntaxTreeNode(mn,kind, zn, sn);}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode IdentifierTuple() throws ParseException {
  SyntaxTreeNode tn;
  SyntaxTreeNode hn[];
  Token t;
  bpa("Identifier tuple");
    t = jj_consume_token(LAB);
               addHeir( new SyntaxTreeNode(mn, t) );
expecting = "Identifier or >>";
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
      tn = Identifier();
                        addHeir( tn );
expecting = "COMMA or >>";
      label_8:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[25] = jj_gen;
          break label_8;
        }
        t = jj_consume_token(COMMA);
                    addHeir( new SyntaxTreeNode(mn, t) );
expecting = "COMMA or >>";
        tn = Identifier();
                          addHeir( tn );
expecting = "COMMA or >>";
      }
      break;
    default:
      jj_la1[26] = jj_gen;
      ;
    }
    t = jj_consume_token(RAB);
               addHeir( new SyntaxTreeNode(mn, t) );
    SyntaxTreeNode sn[] = getLastHeirs();
    epa(); {if (true) return new SyntaxTreeNode( mn, N_IdentifierTuple, sn  );}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode IdentLHS() throws ParseException {
  SyntaxTreeNode tn;
  Token t;
  bpa("Identifier LHS");
    tn = Identifier();
                      addHeir( tn );
expecting = "( or ==";
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LBR:
      t = jj_consume_token(LBR);
                  addHeir( new SyntaxTreeNode(mn, t) );
expecting = "Identifier Declaration, prefix op, _ or )";
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
        tn = IdentDecl();
        break;
      case US:
      case op_76:
      case op_26:
      case op_29:
      case op_58:
      case CASESEP:
      case op_61:
      case op_112:
      case op_113:
      case op_114:
      case op_115:
      case op_116:
        tn = SomeFixDecl();
        break;
      default:
        jj_la1[27] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                                                   addHeir( tn );
expecting = "COMMA or )";
      label_9:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[28] = jj_gen;
          break label_9;
        }
        t = jj_consume_token(COMMA);
                       addHeir( new SyntaxTreeNode(mn, t) );
expecting = "Identifier Declaration, prefix op or _";
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IDENTIFIER:
          tn = IdentDecl();
          break;
        case US:
        case op_76:
        case op_26:
        case op_29:
        case op_58:
        case CASESEP:
        case op_61:
        case op_112:
        case op_113:
        case op_114:
        case op_115:
        case op_116:
          tn = SomeFixDecl();
          break;
        default:
          jj_la1[29] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
                                                     addHeir( tn );
expecting = "COMMA or )";
      }
      t = jj_consume_token(RBR);
                  addHeir( new SyntaxTreeNode(mn, t) );
      break;
    default:
      jj_la1[30] = jj_gen;
      ;
    }
    SyntaxTreeNode sn[] = getLastHeirs();
    epa(); {if (true) return new SyntaxTreeNode( mn, N_IdentLHS, sn);}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode PrefixLHS() throws ParseException {
  SyntaxTreeNode sn[] = new SyntaxTreeNode[2];
  SyntaxTreeNode tn;
  Token t;
  bpa("Prefix LHS");
    t = NEPrefixOpToken();
                            sn[0] = new SyntaxTreeNode(mn, t);
expecting = "Identifier";
    tn = Identifier();
                      sn[1] = tn;
    epa(); {if (true) return new SyntaxTreeNode( mn, N_PrefixLHS, sn );}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode InfixLHS() throws ParseException {
  SyntaxTreeNode sn[] = new SyntaxTreeNode[3];
  SyntaxTreeNode tn;
  Token t;
  bpa("Infix LHS");
    tn = Identifier();
                      sn[0] = tn;
    t = InfixOpToken();
                         sn[1] = new SyntaxTreeNode(mn, t);
    tn = Identifier();
                      sn[2] = tn;
    epa(); {if (true) return new SyntaxTreeNode( mn, N_InfixLHS, sn );}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode PostfixLHS() throws ParseException {
  SyntaxTreeNode sn[] = new SyntaxTreeNode[2];
  SyntaxTreeNode tn;
  Token t;
  bpa("Postfix LHS");
    tn = Identifier();
                      sn[0] = tn;
    t = PostfixOpToken();
                           sn[1] = new SyntaxTreeNode(mn, t);
    epa(); {if (true) return new SyntaxTreeNode( mn, N_PostfixLHS, sn );}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode IdentDecl() throws ParseException {
  SyntaxTreeNode tn;
  Token t;
  bpa("Identifier Declation");
    tn = Identifier();
                      addHeir( tn );
expecting = "( or ...";
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LBR:
      t = jj_consume_token(LBR);
                 addHeir( new SyntaxTreeNode(mn, t) );
expecting = "_";
      t = jj_consume_token(US);
                addHeir( new SyntaxTreeNode(mn, t) );
expecting = "COMMA or )";
      label_10:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[31] = jj_gen;
          break label_10;
        }
        t = jj_consume_token(COMMA);
                     addHeir( new SyntaxTreeNode(mn, t) );
expecting = "_";
        t = jj_consume_token(US);
                  addHeir( new SyntaxTreeNode(mn, t) );
expecting = "COMMA or )";
      }
      t = jj_consume_token(RBR);
                 addHeir( new SyntaxTreeNode(mn, t) );
      break;
    default:
      jj_la1[32] = jj_gen;
      ;
    }
    SyntaxTreeNode sn[] = getLastHeirs();
    epa(); {if (true) return new SyntaxTreeNode( mn, N_IdentDecl, sn);}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode SomeFixDecl() throws ParseException {
  SyntaxTreeNode localASTN = null;
  SyntaxTreeNode tn;
  SyntaxTreeNode sn[] = null;
  int kind;
  Token t;
  UniqueString n;
  bpa("Op. Symbol Declaration");
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case op_76:
    case op_26:
    case op_29:
    case op_58:
    case CASESEP:
    case op_61:
    case op_112:
    case op_113:
    case op_114:
    case op_115:
    case op_116:
      // LOOKAHEAD( <OpSymbol>, { isPrefixDeclOp( getToken(1) )  } )
            tn = NonExpPrefixOp();
        kind = N_PrefixDecl; n = lastOp.getIdentifier();
        sn = new SyntaxTreeNode[2]; sn[0] = tn;
expecting = "_";
      t = jj_consume_token(US);
                  sn[1] = new SyntaxTreeNode(mn, t);
      break;
    case US:
      t = jj_consume_token(US);
expecting = "infix or postfix operator";
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case op_1:
      case AND:
      case op_3:
      case op_4:
      case OR:
      case op_6:
      case op_7:
      case op_8:
      case op_9:
      case op_10:
      case op_11:
      case op_12:
      case op_13:
      case op_14:
      case op_15:
      case op_16:
      case op_17:
      case op_18:
      case op_19:
      case IN:
      case op_21:
      case op_22:
      case op_23:
      case op_24:
      case op_25:
      case op_27:
      case op_30:
      case op_31:
      case op_32:
      case op_33:
      case op_34:
      case op_35:
      case op_36:
      case op_37:
      case op_38:
      case op_39:
      case op_40:
      case op_41:
      case op_42:
      case op_43:
      case op_44:
      case op_45:
      case op_46:
      case op_47:
      case op_48:
      case op_49:
      case op_50:
      case op_51:
      case op_52:
      case op_53:
      case op_54:
      case op_55:
      case op_56:
      case op_59:
      case op_62:
      case op_63:
      case op_64:
      case EQUALS:
      case op_66:
      case op_67:
      case op_71:
      case op_72:
      case op_73:
      case op_74:
      case op_75:
      case op_77:
      case op_78:
      case op_79:
      case op_80:
      case op_81:
      case op_82:
      case op_83:
      case op_84:
      case op_85:
      case op_86:
      case op_87:
      case op_88:
      case op_89:
      case op_90:
      case op_91:
      case op_92:
      case op_93:
      case op_94:
      case op_95:
      case op_96:
      case op_97:
      case op_98:
      case op_100:
      case op_101:
      case op_102:
      case op_103:
      case op_104:
      case op_105:
      case op_106:
      case op_107:
      case op_108:
      case op_109:
      case op_110:
      case op_111:
      case op_117:
      case op_118:
      case op_119:
        tn = InfixOp();
          kind = N_InfixDecl; n = lastOp.getIdentifier();
          sn = new SyntaxTreeNode[3]; sn[1] = tn;
          sn[0] =  new SyntaxTreeNode(mn, t);
expecting = "_";
        t = jj_consume_token(US);
                       sn[2] = new SyntaxTreeNode(mn, t);
        break;
      case op_57:
      case op_68:
      case op_69:
      case op_70:
        tn = PostfixOp();
          kind = N_PostfixDecl; n = lastOp.getIdentifier();
          sn = new SyntaxTreeNode[2]; sn[1] = tn;
          sn[0] =  new SyntaxTreeNode(mn, t);
        break;
      default:
        jj_la1[33] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[34] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    epa(); {if (true) return new SyntaxTreeNode(mn, kind, sn);}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode Instance() throws ParseException {
  SyntaxTreeNode tn;
  SyntaxTreeNode zn = null;
  Token t;
  bpa("Instance");
expecting = "LOCAL or instance";
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LOCAL:
      t = jj_consume_token(LOCAL);
    zn =  new SyntaxTreeNode(mn, t);
      break;
    default:
      jj_la1[35] = jj_gen;
      ;
    }
    tn = Instantiation();
                         addHeir( tn );
expecting = "COMMA or Module Body";
    SyntaxTreeNode sn[] = getLastHeirs();
    epa(); {if (true) return new SyntaxTreeNode( mn, N_Instance, zn, sn);}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode Instantiation() throws ParseException {
  SyntaxTreeNode tn;
  Token t;
  bpa("NonLocalInstance");
    t = jj_consume_token(INSTANCE);
                    addHeir( new SyntaxTreeNode(mn, t) );
expecting = "Module identifier";
  t = getToken(1);
  if (isFieldNameToken( t )) t.kind = IDENTIFIER;
    tn = Identifier();
                      addDependency( tn.image ); addHeir( tn );
expecting = "WITH or another definition.";
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WITH:
      t = jj_consume_token(WITH);
                  addHeir( new SyntaxTreeNode(mn, t) );
expecting = emptyString;
      tn = Substitution();
                          addHeir( tn );
expecting = emptyString;
      label_11:
      while (true) {
        if (jj_2_10(3)) {
          ;
        } else {
          break label_11;
        }
        t = jj_consume_token(COMMA);
                     addHeir( new SyntaxTreeNode(mn, t) );
expecting = emptyString;
        tn = Substitution();
                            addHeir( tn );
expecting = emptyString;
      }
      break;
    default:
      jj_la1[36] = jj_gen;
      ;
    }
    SyntaxTreeNode sn[] = getLastHeirs();
    epa(); {if (true) return new SyntaxTreeNode( mn, N_NonLocalInstance, sn);}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode Substitution() throws ParseException {
  SyntaxTreeNode zn[] = new SyntaxTreeNode[3];
  SyntaxTreeNode tn = null;
  Token t;
  anchor = null;
  String n;
  bpa("Substitution");
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
      tn = Identifier();
                        zn[0] = tn;
      break;
    case op_76:
    case op_26:
    case op_29:
    case op_58:
    case CASESEP:
    case op_61:
    case op_112:
    case op_113:
    case op_114:
    case op_115:
    case op_116:
      tn = NonExpPrefixOp();
                            zn[0] = tn;
      break;
    case op_1:
    case AND:
    case op_3:
    case op_4:
    case OR:
    case op_6:
    case op_7:
    case op_8:
    case op_9:
    case op_10:
    case op_11:
    case op_12:
    case op_13:
    case op_14:
    case op_15:
    case op_16:
    case op_17:
    case op_18:
    case op_19:
    case IN:
    case op_21:
    case op_22:
    case op_23:
    case op_24:
    case op_25:
    case op_27:
    case op_30:
    case op_31:
    case op_32:
    case op_33:
    case op_34:
    case op_35:
    case op_36:
    case op_37:
    case op_38:
    case op_39:
    case op_40:
    case op_41:
    case op_42:
    case op_43:
    case op_44:
    case op_45:
    case op_46:
    case op_47:
    case op_48:
    case op_49:
    case op_50:
    case op_51:
    case op_52:
    case op_53:
    case op_54:
    case op_55:
    case op_56:
    case op_59:
    case op_62:
    case op_63:
    case op_64:
    case EQUALS:
    case op_66:
    case op_67:
    case op_71:
    case op_72:
    case op_73:
    case op_74:
    case op_75:
    case op_77:
    case op_78:
    case op_79:
    case op_80:
    case op_81:
    case op_82:
    case op_83:
    case op_84:
    case op_85:
    case op_86:
    case op_87:
    case op_88:
    case op_89:
    case op_90:
    case op_91:
    case op_92:
    case op_93:
    case op_94:
    case op_95:
    case op_96:
    case op_97:
    case op_98:
    case op_100:
    case op_101:
    case op_102:
    case op_103:
    case op_104:
    case op_105:
    case op_106:
    case op_107:
    case op_108:
    case op_109:
    case op_110:
    case op_111:
    case op_117:
    case op_118:
    case op_119:
      tn = InfixOp();
                     zn[0] = tn;
      break;
    case op_57:
    case op_68:
    case op_69:
    case op_70:
      tn = PostfixOp();
                       zn[0] = tn;
      break;
    default:
      jj_la1[37] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  expecting = "<-";
    t = jj_consume_token(SUBSTITUTE);
                     n = tn.getImage();
     zn[1] = new SyntaxTreeNode(mn, t);
expecting = "Expression or Op. Symbol";
    try {
      if (jj_2_11(2147483647)) {
        t = jj_consume_token(op_76);
      SyntaxTreeNode zzn[] = new SyntaxTreeNode[2];
      zzn[0] = new SyntaxTreeNode( mn, N_IdPrefix, new SyntaxTreeNode[0] );
      zzn[1] =  new SyntaxTreeNode( mn, N_NonExpPrefixOp, t );
      tn = new SyntaxTreeNode( mn, N_GenNonExpPrefixOp, zzn );
      } else if (jj_2_12(1)) {
        tn = Expression();
      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
    } catch (ParseException e) {
// first things first - restore evaluation stack
    OperatorStack.popStack();
// check the nature of the node returned. It can only be a GenOp. */
    if ( ( anchor != null )
       &&( anchor.isKind( N_GenNonExpPrefixOp ) || anchor.isKind( N_GenInfixOp ) || anchor.isKind( N_GenPostfixOp ) ) ) {
       tn = anchor; anchor = null;
    } else
       {if (true) throw e;}
    }
    epa(); zn[2] = tn; {if (true) return new SyntaxTreeNode(mn, N_Substitution, zn );}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode PrefixOp() throws ParseException {
  Token t;
    t = PrefixOpToken();
    lastOp = Operators.getOperator( util.UniqueString.uniqueStringOf(t.image) ); // YYY to revise
    {if (true) return new SyntaxTreeNode(mn, N_PrefixOp, t) ;}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode NonExpPrefixOp() throws ParseException {
  Token t;
    t = NEPrefixOpToken();
    lastOp = Operators.getOperator( util.UniqueString.uniqueStringOf(t.image) ); // YYY to revise
    {if (true) return new SyntaxTreeNode(mn, N_NonExpPrefixOp, t) ;}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode InfixOp() throws ParseException {
  Token t;
    t = InfixOpToken();
    lastOp = Operators.getOperator( util.UniqueString.uniqueStringOf(t.image) ); // YYY to revise
    {if (true) return new SyntaxTreeNode( mn, N_InfixOp, t) ;}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode PostfixOp() throws ParseException {
  Token t;
    t = PostfixOpToken();
    lastOp = Operators.getOperator( util.UniqueString.uniqueStringOf(t.image) ); // YYY to revise
    {if (true) return new SyntaxTreeNode(mn, N_PostfixOp, t) ;}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode Identifier() throws ParseException {
  Token t;
    t = jj_consume_token(IDENTIFIER);
                     {if (true) return new SyntaxTreeNode(mn, t);}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode Assumption() throws ParseException {
  SyntaxTreeNode tn;
  SyntaxTreeNode zn = null;
  Token t;
  bpa("Assumption");
expecting = "LOCAL or ASSUM...";
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LOCAL:
      t = jj_consume_token(LOCAL);
                  zn = new SyntaxTreeNode(mn, t);
      break;
    default:
      jj_la1[38] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ASSUME:
      t = jj_consume_token(ASSUME);
      break;
    case ASSUMPTION:
      t = jj_consume_token(ASSUMPTION);
      break;
    default:
      jj_la1[39] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                                        addHeir( new SyntaxTreeNode(mn, t) );
    if (jj_2_13(2)) {
      /* because of Expression, following */
          tn = Identifier();
                        addHeir( tn );
expecting = "==";
      t = jj_consume_token(DEF);
                       belchDEF(); addHeir( new SyntaxTreeNode(mn, t) );
    } else {
      ;
    }
     belchDEF();
expecting = "Assume-Prove or Expression";
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ASSUME:
      tn = AssumeProve();
      break;
    default:
      jj_la1[40] = jj_gen;
      if (jj_2_14(1)) {
        tn = Expression();
      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    addHeir(tn);
    SyntaxTreeNode sn[] = getLastHeirs();
    epa(); {if (true) return new SyntaxTreeNode( mn, N_Assumption, zn, sn);}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode AssumeProve() throws ParseException {
  SyntaxTreeNode tn;
  Token t;
  bpa("Assume-Prove");
    t = jj_consume_token(ASSUME);
                  addHeir( new SyntaxTreeNode(mn, t) );
expecting = "Numbered Assume-Prove";
    label_12:
    while (true) {
      tn = NumberedAssumeProve();
                                  addHeir(tn);
      if (jj_2_15(1)) {
        ;
      } else {
        break label_12;
      }
    }
expecting = "PROVE";
    t = jj_consume_token(PROVE);
    BStack.newReference(t.endColumn, PROVE );
    addHeir( new SyntaxTreeNode(mn, t) );
expecting = "Expression";
    tn = Expression();
    BStack.popReference(); addHeir( tn );
    SyntaxTreeNode sn[] = getLastHeirs();
    epa(); {if (true) return new SyntaxTreeNode( mn, N_AssumeProve, sn);}
    throw new Error("Missing return statement in function");
  }

// number . sequence 
  final public SyntaxTreeNode NumberedAssumeProve() throws ParseException {
  SyntaxTreeNode tn;
  Token t;
  boolean b = false;
  bpa("Numbered Assume-Prove");
    if (jj_2_16(2)) {
      t = jj_consume_token(NUMBER_LITERAL);
                            addHeir( new SyntaxTreeNode(mn, t) );
expecting = ".";
      t = jj_consume_token(DOT);
      BStack.newReference(t.endColumn, ASSUME); b = true;
      addHeir( new SyntaxTreeNode(mn, t) );
expecting = "Assume-Prove, Assume-Decl or expression";
    } else {
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ASSUME:
      tn = AssumeProve();
      break;
    default:
      jj_la1[41] = jj_gen;
      if (IsNotExpression()) {
        tn = AssumeDecl();
      } else if (jj_2_17(1)) {
        tn = Expression();
      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    if (b) BStack.popReference();
    addHeir(tn);
    SyntaxTreeNode sn[] = getLastHeirs();
    epa(); {if (true) return new SyntaxTreeNode( mn, N_NumberedAssumeProve, sn);}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode AssumeDecl() throws ParseException {
  SyntaxTreeNode zn[] = null;
  SyntaxTreeNode tn;
  Token t;
  bpa("Assume Decl.");
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case VARIABLE:
      tn = VariableDeclaration();
                                 zn = new SyntaxTreeNode[1]; zn[0] = tn;
      break;
    case ACTION:
    case CONSTANT:
    case PARAMETER:
    case PREDICATE:
    case STATE:
    case TEMPORAL:
    case TRANSITION:
      tn = ParamDeclaration();
        zn = new SyntaxTreeNode[2]; zn[0] = tn;
expecting = "optional \\in or ...";
      zn[1] = MaybeBound();
      break;
    default:
      jj_la1[42] = jj_gen;
      if (jj_2_18(2)) {
        tn = OperatorOrFunctionDefinition();
                                                        zn = new SyntaxTreeNode[1]; zn[0] = tn;
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case INSTANCE:
        case LOCAL:
          tn = Instance();
                      zn = new SyntaxTreeNode[1]; zn[0] = tn;
          break;
        default:
          jj_la1[43] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
    epa();
    {if (true) return new SyntaxTreeNode( mn, N_AssumeDecl, zn );}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode MaybeBound() throws ParseException {
  SyntaxTreeNode zn[] = null;
  SyntaxTreeNode tn;
  Token t;
  bpa("Domain binding");
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IN:
      t = jj_consume_token(IN);
      zn    = new SyntaxTreeNode[2];
      zn[0] =  new SyntaxTreeNode(mn, t);
      zn[0].setKind(T_IN);
expecting = "Expression";
      zn[1] = Expression();
      break;
    default:
      jj_la1[44] = jj_gen;
      ;
    }
    epa(); {if (true) return new SyntaxTreeNode( mn, N_MaybeBound, zn);}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode Theorem() throws ParseException {
  SyntaxTreeNode zn = null;
  SyntaxTreeNode tn;
  Token t;
  bpa("Theorem");
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LOCAL:
      t = jj_consume_token(LOCAL);
                  zn = new SyntaxTreeNode(mn, t);
      break;
    default:
      jj_la1[45] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case THEOREM:
      t = jj_consume_token(THEOREM);
      break;
    case PROPOSITION:
      t = jj_consume_token(PROPOSITION);
      break;
    default:
      jj_la1[46] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                                          addHeir( new SyntaxTreeNode(mn, t) );
expecting = "Identifier, Assume-Prove or Expression";
    if (jj_2_19(2)) {
      tn = Identifier();
                        addHeir( tn );
expecting = "==";
      t = jj_consume_token(DEF);
                       belchDEF(); addHeir( new SyntaxTreeNode(mn, t) );
    } else {
      ;
    }
    belchDEF();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ASSUME:
      tn = AssumeProve();
      break;
    default:
      jj_la1[47] = jj_gen;
      if (jj_2_20(1)) {
        tn = Expression();
      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    addHeir(tn);  SyntaxTreeNode sn[] = getLastHeirs();
    epa(); {if (true) return new SyntaxTreeNode( mn, N_Theorem, zn, sn);}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode Proof() throws ParseException {
  SyntaxTreeNode tn = null;
  Token t;
  bpa("Proof");
    t = jj_consume_token(PROOF);
                 addHeir( new SyntaxTreeNode(mn, t) );
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OF:
      tn = ProofName();
                       addHeir( tn );
      break;
    default:
      jj_la1[48] = jj_gen;
      ;
    }
    tn = InnerProof();
                       addHeir(tn);
    t = jj_consume_token(ENDPROOF);
                          addHeir( new SyntaxTreeNode(mn, t) );
    SyntaxTreeNode sn[] = getLastHeirs();
    epa(); {if (true) return new SyntaxTreeNode( mn, N_Proof, sn);}
    throw new Error("Missing return statement in function");
  }

/* there is a tail recursion for Innerproof through ProofStep and QEDStep. However, they shouldn't
   be at the same step level.
   We have to use the fact that there is a QEDStep.
*/
  final public SyntaxTreeNode InnerProof() throws ParseException {
  SyntaxTreeNode tn;
  Token t;
  boolean QEDfound = false;
  int level = -1;
  bpa("Inner Proof");
    if (jj_2_22(1)) {
      if (jj_2_21(1)) {
        label_13:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case ProofStepLexeme:
            tn = AStep();
            break;
          case LET:
            tn = ProofLet();
            break;
          default:
            jj_la1[49] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
           addHeir(tn);
           if (! tn.isKind(N_ProofLet)) {
             if (tn.isKind( N_QEDStep )) QEDfound = true;
             if (level == -1) level = numberFromStep( tn.first().getImage() );
             else
               if ( level != numberFromStep( tn.first().getImage() ) )
                 {if (true) throw new ParseException( " - Mismatch in proof levels or missing QED step at " + tn.getLocation().toString() );} }
          if (! QEDfound) {
            ;
          } else {
            break label_13;
          }
        }
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case PF:
          tn = LeafProof();
                          addHeir(tn);
          break;
        default:
          jj_la1[50] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    } else {
      ;
    }
    SyntaxTreeNode sn[] = getLastHeirs();
    epa(); {if (true) return new SyntaxTreeNode( mn, N_InnerProof, sn);}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode ProofName() throws ParseException {
  SyntaxTreeNode zn[] = new SyntaxTreeNode[2];
  SyntaxTreeNode tn;
  Token t;
  bpa("Proof Name");
    t = jj_consume_token(OF);
                     zn[0] = new SyntaxTreeNode(mn, t);
    tn = Identifier();
                      zn[1] = tn;
    epa(); {if (true) return new SyntaxTreeNode( mn, N_ProofName, zn);}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode ProofLet() throws ParseException {
  SyntaxTreeNode zn[] = new SyntaxTreeNode[2];
  SyntaxTreeNode tn;
  Token t;
  bpa("Proof-Let");
    t = jj_consume_token(LET);
                        zn[0] = new SyntaxTreeNode(mn, t);
    tn = LetDefinitions();
                          zn[1] = tn;
    epa(); {if (true) return new SyntaxTreeNode( mn, N_ProofLet, zn);}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode LeafProof() throws ParseException {
  SyntaxTreeNode zn[] = new SyntaxTreeNode[1];
  Token t;
  bpa("Leaf Proof");
    t = jj_consume_token(PF);
              addHeir( new SyntaxTreeNode(mn, t) ); skipOver( t.beginColumn );
    epa(); {if (true) return new SyntaxTreeNode( mn, N_LeafProof, zn);}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode AStep() throws ParseException {
  SyntaxTreeNode zn[] = new SyntaxTreeNode[4];
  SyntaxTreeNode tn;
  Token t;
  int kind;
  bpa("Proof or QED Step");
    t = jj_consume_token(ProofStepLexeme);
                          zn[0] =  new SyntaxTreeNode(mn, t);
    t = jj_consume_token(DOT);
    zn[1] =  new SyntaxTreeNode(mn, t);
    BStack.newReference(t.endColumn, PROOF);
    if (jj_2_23(1)) {
      tn = ProofStatement();
      zn[2] = tn; kind = N_ProofStep;
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case QED:
        t = jj_consume_token(QED);
      zn[2] = new SyntaxTreeNode(mn, t); kind = N_QEDStep;
        break;
      default:
        jj_la1[51] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    BStack.popReference();
    zn[3] = InnerProof();
    epa(); {if (true) return new SyntaxTreeNode( mn, kind, zn);}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode QEDStep() throws ParseException {
  SyntaxTreeNode zn[] = new SyntaxTreeNode[4];
  SyntaxTreeNode tn;
  Token t;
  bpa("QED step");
    t = jj_consume_token(ProofStepLexeme);
                          zn[0] =  new SyntaxTreeNode(mn, t);
    t = jj_consume_token(DOT);
              zn[1] =  new SyntaxTreeNode(mn, t);
    t = jj_consume_token(QED);
              zn[2] =  new SyntaxTreeNode(mn, t);
    zn[3] = InnerProof();
    epa(); {if (true) return new SyntaxTreeNode( mn, N_QEDStep, zn);}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode ProofStep() throws ParseException {
  SyntaxTreeNode zn[] = new SyntaxTreeNode[4];
  SyntaxTreeNode tn;
  Token t;
  bpa("Proof Step");
    t = jj_consume_token(ProofStepLexeme);
                          zn[0] =  new SyntaxTreeNode(mn, t);
    t = jj_consume_token(DOT);
              zn[1] =  new SyntaxTreeNode(mn, t);
    BStack.newReference(t.endColumn, PROOF);
    zn[2] = ProofStatement();
    BStack.popReference();
    zn[3] = InnerProof();
    epa(); {if (true) return new SyntaxTreeNode( mn, N_ProofStep, zn);}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode ProofStatement() throws ParseException {
  // N_ProofStatement 
  SyntaxTreeNode tn;
  Token t;
  bpa("Proof Statement");
    if (jj_2_24(2147483647) && (true)) {
      tn = CaseStatement();
    } else if (jj_2_25(2147483647) && (true)) {
      tn = ChooseStatement();
    } else if (jj_2_26(1)) {
      tn = Expression();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case ASSUME:
        tn = AssumeProve();
        break;
      default:
        jj_la1[52] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
      epa(); {if (true) return tn;}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode CaseStatement() throws ParseException {
  SyntaxTreeNode zn[] = new SyntaxTreeNode[2];
  SyntaxTreeNode tn;
  Token t;
  bpa("CASE Statement");
    t = jj_consume_token(CASE);
//    BStack.newReference(t.endColumn, CASE);
    zn[0] =  new SyntaxTreeNode(mn, t);
    tn = Expression();
    zn[1] = tn;
//    BStack.popReference();
    epa(); {if (true) return new SyntaxTreeNode( mn, N_CaseStatement, zn);}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode ChooseStatement() throws ParseException {
  SyntaxTreeNode zn[] = new SyntaxTreeNode[5];
  SyntaxTreeNode tn;
  Token t;
  bpa("CHOOSE Statement");
    t = jj_consume_token(CHOOSE);
    zn[0] =  new SyntaxTreeNode(mn, t);
    //    BStack.newReference(t.endColumn, CHOOSE);
      zn[1] = Identifier();

    zn[2] = MaybeBound();

    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COLON:
      t = jj_consume_token(COLON);
      break;
    case ST:
      t = jj_consume_token(ST);
      break;
    default:
      jj_la1[53] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                               zn[3] = new SyntaxTreeNode(mn, t);
    zn[4] = Expression();
//    BStack.popReference();
    epa(); {if (true) return new SyntaxTreeNode( mn, N_ChooseStatement, zn);}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode GeneralId() throws ParseException {
  SyntaxTreeNode zn[] = new SyntaxTreeNode[2];
  Token t;
  bpa("General ID");
    zn[0] = IdPrefix();
    zn[1] = Identifier();
    epa(); {if (true) return new SyntaxTreeNode( mn, N_GeneralId, zn);}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode IdPrefix() throws ParseException {
  SyntaxTreeNode tn;
  bpa("ID Prefix");
    label_14:
    while (true) {
      if (jj_2_27(2147483647)) {
        ;
      } else {
        break label_14;
      }
      tn = IdPrefixElement();
                            addHeir( tn );
    }
    SyntaxTreeNode sn[] = getLastHeirs();
    epa(); {if (true) return new SyntaxTreeNode(mn, N_IdPrefix, sn );}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode IdPrefixElement() throws ParseException {
  SyntaxTreeNode tn;
  Token t;
  bpa("ID Prefix Element");
    tn = Identifier();
                      addHeir( tn );
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LBR:
      tn = OpArgs();
                   addHeir( tn );
      break;
    default:
      jj_la1[54] = jj_gen;
      ;
    }
    t = jj_consume_token(BANG);
               addHeir( new SyntaxTreeNode(mn, t) );
    SyntaxTreeNode sn[] = getLastHeirs();
    epa(); {if (true) return  new SyntaxTreeNode(mn, N_IdPrefixElement, sn);}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode ParenthesesExpression() throws ParseException {
  SyntaxTreeNode tn;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LBR:
      tn = ParenExpr();
      break;
    case LBC:
      tn = BraceCases();
      break;
    case LSB:
      tn = SBracketCases();
      break;
    case LWB:
      tn = SetExcept();
      break;
    case LAB:
      tn = TupleOrAction();
      break;
    case SF:
    case WF:
      tn = FairnessExpr();
      break;
    default:
      jj_la1[55] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return tn;}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode ClosedExpressionOrOp() throws ParseException {
  SyntaxTreeNode tn;
  Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NUMBER_LITERAL:
    case STRING_LITERAL:
    case op_57:
    case op_68:
    case op_69:
    case op_70:
    case op_26:
    case op_29:
    case op_58:
    case CASESEP:
    case op_61:
    case op_112:
    case op_113:
    case op_114:
    case op_115:
    case op_116:
    case op_1:
    case AND:
    case op_3:
    case op_4:
    case OR:
    case op_6:
    case op_7:
    case op_8:
    case op_9:
    case op_10:
    case op_11:
    case op_12:
    case op_13:
    case op_14:
    case op_15:
    case op_16:
    case op_17:
    case op_18:
    case op_19:
    case IN:
    case op_21:
    case op_22:
    case op_23:
    case op_24:
    case op_25:
    case op_27:
    case op_30:
    case op_31:
    case op_32:
    case op_33:
    case op_34:
    case op_35:
    case op_36:
    case op_37:
    case op_38:
    case op_39:
    case op_40:
    case op_41:
    case op_42:
    case op_43:
    case op_44:
    case op_45:
    case op_46:
    case op_47:
    case op_48:
    case op_49:
    case op_50:
    case op_51:
    case op_52:
    case op_53:
    case op_54:
    case op_55:
    case op_56:
    case op_59:
    case op_62:
    case op_63:
    case op_64:
    case EQUALS:
    case op_66:
    case op_67:
    case op_71:
    case op_72:
    case op_73:
    case op_74:
    case op_75:
    case op_77:
    case op_78:
    case op_79:
    case op_80:
    case op_81:
    case op_82:
    case op_83:
    case op_84:
    case op_85:
    case op_86:
    case op_87:
    case op_88:
    case op_89:
    case op_90:
    case op_91:
    case op_92:
    case op_93:
    case op_94:
    case op_95:
    case op_96:
    case op_97:
    case op_98:
    case op_100:
    case op_101:
    case op_102:
    case op_103:
    case op_104:
    case op_105:
    case op_106:
    case op_107:
    case op_108:
    case op_109:
    case op_110:
    case op_111:
    case op_117:
    case op_118:
    case op_119:
    case IDENTIFIER:
      tn = ElementaryExpression();
      break;
    case SF:
    case WF:
    case LBR:
    case LSB:
    case LWB:
    case LBC:
    case LAB:
      tn = ParenthesesExpression();
      break;
    default:
      jj_la1[56] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return tn;}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode ClosedExpressionOnly() throws ParseException {
  SyntaxTreeNode tn;
    tn = ClosedExpressionOrOp();
    if ( isGenOp( tn ) ) {if (true) throw new ParseException( "Encountered unexpected Operator" );}
    else {if (true) return tn;}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode OpenExpression() throws ParseException {
  SyntaxTreeNode tn;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EXISTS:
    case FORALL:
      tn = SomeQuant();
      break;
    case T_EXISTS:
    case T_FORALL:
      tn = SomeTQuant();
      break;
    case IF:
      tn = IfThenElse();
      break;
    case CASE:
      tn = Case();
      break;
    case LET:
      tn = LetIn();
      break;
    case CHOOSE:
      tn = UnboundOrBoundChoose();
      break;
    default:
      jj_la1[57] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return tn;}
    throw new Error("Missing return statement in function");
  }

/*
  L.GeneralId, L.OpApplication, L.String, L.Number, L.GenOp...
*/
  final public SyntaxTreeNode ElementaryExpression() throws ParseException {
  SyntaxTreeNode tn;
  Token t;
  bpa("Elementary expression");
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case op_57:
    case op_68:
    case op_69:
    case op_70:
    case op_26:
    case op_29:
    case op_58:
    case CASESEP:
    case op_61:
    case op_112:
    case op_113:
    case op_114:
    case op_115:
    case op_116:
    case op_1:
    case AND:
    case op_3:
    case op_4:
    case OR:
    case op_6:
    case op_7:
    case op_8:
    case op_9:
    case op_10:
    case op_11:
    case op_12:
    case op_13:
    case op_14:
    case op_15:
    case op_16:
    case op_17:
    case op_18:
    case op_19:
    case IN:
    case op_21:
    case op_22:
    case op_23:
    case op_24:
    case op_25:
    case op_27:
    case op_30:
    case op_31:
    case op_32:
    case op_33:
    case op_34:
    case op_35:
    case op_36:
    case op_37:
    case op_38:
    case op_39:
    case op_40:
    case op_41:
    case op_42:
    case op_43:
    case op_44:
    case op_45:
    case op_46:
    case op_47:
    case op_48:
    case op_49:
    case op_50:
    case op_51:
    case op_52:
    case op_53:
    case op_54:
    case op_55:
    case op_56:
    case op_59:
    case op_62:
    case op_63:
    case op_64:
    case EQUALS:
    case op_66:
    case op_67:
    case op_71:
    case op_72:
    case op_73:
    case op_74:
    case op_75:
    case op_77:
    case op_78:
    case op_79:
    case op_80:
    case op_81:
    case op_82:
    case op_83:
    case op_84:
    case op_85:
    case op_86:
    case op_87:
    case op_88:
    case op_89:
    case op_90:
    case op_91:
    case op_92:
    case op_93:
    case op_94:
    case op_95:
    case op_96:
    case op_97:
    case op_98:
    case op_100:
    case op_101:
    case op_102:
    case op_103:
    case op_104:
    case op_105:
    case op_106:
    case op_107:
    case op_108:
    case op_109:
    case op_110:
    case op_111:
    case op_117:
    case op_118:
    case op_119:
    case IDENTIFIER:
      tn = Extension();
      break;
    case STRING_LITERAL:
      tn = String();
                    epa();
      break;
    case NUMBER_LITERAL:
      tn = Number();
                    epa();
      break;
    default:
      jj_la1[58] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return tn;}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode String() throws ParseException {
  SyntaxTreeNode tn;
  Token t;
  bpa("String");
    t = jj_consume_token(STRING_LITERAL);
    tn = new SyntaxTreeNode( mn, N_String, t);
    epa();
    {if (true) return tn;}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode Number() throws ParseException {
  SyntaxTreeNode tn, sn[] = null;
  Token t1, t2;
  int kind = N_Number;
    t1 = jj_consume_token(NUMBER_LITERAL);
    if (jj_2_28(2)) {
      t2 = jj_consume_token(DOT);
     kind = N_Real;
     decimalFlag = true;
     sn = new SyntaxTreeNode[3];
     sn[0] = new SyntaxTreeNode(mn, t1);
     sn[1] = new SyntaxTreeNode(mn, t2);
      t1 = jj_consume_token(NUMBER_LITERAL);
     sn[2] = new SyntaxTreeNode(mn,t1);
    } else {
      ;
    }
    if (sn == null) {
      numberFlag = true;
      sn = new SyntaxTreeNode[1];
      sn[0] =  new SyntaxTreeNode(mn, t1);
      kind = N_Number;
    }
    {if (true) return new SyntaxTreeNode(mn, kind, sn);}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode Extension() throws ParseException {
  SyntaxTreeNode last = null, tid, top = null;
  Token t = null;
  SyntaxTreeNode heirs[];
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case op_26:
    case op_29:
    case op_58:
    case CASESEP:
    case op_61:
    case op_112:
    case op_113:
    case op_114:
    case op_115:
    case op_116:
      //  LOOKAHEAD( { isPrefixOp( getToken(1) )  } )
            top = PrefixOp();
        heirs = new SyntaxTreeNode[2];
        heirs[0] = new SyntaxTreeNode( mn, N_IdPrefix, getLastHeirs() );
        heirs[1] = top;
        last = new SyntaxTreeNode( mn, N_GenPrefixOp, heirs );
        epa();
      break;
    case op_1:
    case AND:
    case op_3:
    case op_4:
    case OR:
    case op_6:
    case op_7:
    case op_8:
    case op_9:
    case op_10:
    case op_11:
    case op_12:
    case op_13:
    case op_14:
    case op_15:
    case op_16:
    case op_17:
    case op_18:
    case op_19:
    case IN:
    case op_21:
    case op_22:
    case op_23:
    case op_24:
    case op_25:
    case op_27:
    case op_30:
    case op_31:
    case op_32:
    case op_33:
    case op_34:
    case op_35:
    case op_36:
    case op_37:
    case op_38:
    case op_39:
    case op_40:
    case op_41:
    case op_42:
    case op_43:
    case op_44:
    case op_45:
    case op_46:
    case op_47:
    case op_48:
    case op_49:
    case op_50:
    case op_51:
    case op_52:
    case op_53:
    case op_54:
    case op_55:
    case op_56:
    case op_59:
    case op_62:
    case op_63:
    case op_64:
    case EQUALS:
    case op_66:
    case op_67:
    case op_71:
    case op_72:
    case op_73:
    case op_74:
    case op_75:
    case op_77:
    case op_78:
    case op_79:
    case op_80:
    case op_81:
    case op_82:
    case op_83:
    case op_84:
    case op_85:
    case op_86:
    case op_87:
    case op_88:
    case op_89:
    case op_90:
    case op_91:
    case op_92:
    case op_93:
    case op_94:
    case op_95:
    case op_96:
    case op_97:
    case op_98:
    case op_100:
    case op_101:
    case op_102:
    case op_103:
    case op_104:
    case op_105:
    case op_106:
    case op_107:
    case op_108:
    case op_109:
    case op_110:
    case op_111:
    case op_117:
    case op_118:
    case op_119:
      // LOOKAHEAD( { isInfixOp( getToken(1) )  } )
            top = InfixOp();
        heirs = new SyntaxTreeNode[2];
        heirs[0] = new SyntaxTreeNode( mn, N_IdPrefix, getLastHeirs() );
        heirs[1] = top;
        last =  new SyntaxTreeNode( mn, N_GenInfixOp, heirs );
        epa();
      break;
    case op_57:
    case op_68:
    case op_69:
    case op_70:
      // LOOKAHEAD( { isPostfixOp( getToken(1) )  } )
            top = PostfixOp();
        heirs = new SyntaxTreeNode[2];
        heirs[0] = new SyntaxTreeNode( mn, N_IdPrefix, getLastHeirs() );
        heirs[1] = top;
        last =  new SyntaxTreeNode( mn, N_GenPostfixOp, heirs );
        epa();
      break;
    case IDENTIFIER:
      tid = Identifier();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LBR:
        top = OpArgs();
        break;
      default:
        jj_la1[59] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BANG:
        t = jj_consume_token(BANG);
        if ( top == null ) {
          heirs = new SyntaxTreeNode[2];
          heirs[1] = new SyntaxTreeNode( mn, t );
        } else {
          heirs = new SyntaxTreeNode[3];
          heirs[1] = top;
          heirs[2] = new SyntaxTreeNode(mn, t );
        }
        heirs[0] = tid;
        SyntaxTreeNode current = new SyntaxTreeNode( mn, N_IdPrefixElement, heirs );
        addHeir( current );
        last = Extension();
        break;
      default:
        jj_la1[60] = jj_gen;
        ;
      }
      if ( last == null ) {
         if ( top == null ) {
           heirs = new SyntaxTreeNode[2];
           heirs[0] = new SyntaxTreeNode( mn, N_IdPrefix, getLastHeirs() );
           heirs[1] = tid;
           last = new SyntaxTreeNode( mn, N_GeneralId, heirs );
         } else {
/* XXX Wrong.
           addHeir( tid );
           tid = new SyntaxTreeNode( mn, N_GeneralId, getLastHeirs() );
*/
           heirs = new SyntaxTreeNode[2];
           heirs[0] = new SyntaxTreeNode( mn, N_IdPrefix, getLastHeirs() );
           heirs[1] = tid;
           tid = new SyntaxTreeNode( mn, N_GeneralId, heirs );

           heirs = new SyntaxTreeNode[2];
           heirs[0] = tid;
           heirs[1] = top;
           last = new SyntaxTreeNode( mn, N_OpApplication, heirs );
         }
         epa();
      }
      break;
    default:
      jj_la1[61] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return last;}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode OpArgs() throws ParseException {
                      // OpSuite contributes to Heir list.
  SyntaxTreeNode tn;
  Token t;
  bpa("Optional Arguments");
    t = jj_consume_token(LBR);
               addHeir( new SyntaxTreeNode(mn, t) );
    OpSuite();
    label_15:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[62] = jj_gen;
        break label_15;
      }
      t = jj_consume_token(COMMA);
                  addHeir( new SyntaxTreeNode(mn, t) );
      OpSuite();
    }
    t = jj_consume_token(RBR);
               addHeir( new SyntaxTreeNode(mn, t) );
    SyntaxTreeNode sn[] = getLastHeirs();
    epa(); {if (true) return new SyntaxTreeNode(mn, N_OpArgs, sn);}
    throw new Error("Missing return statement in function");
  }

  final public void OpSuite() throws ParseException {
  SyntaxTreeNode tn = null;
  anchor = null;
  Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case op_76:
      t = jj_consume_token(op_76);
    tn = new SyntaxTreeNode(mn, N_NonExpPrefixOp, t);
    SyntaxTreeNode heirs[] = new SyntaxTreeNode[2];
    heirs[0] = new SyntaxTreeNode( mn, N_IdPrefix, ( SyntaxTreeNode []) null );
    heirs[1] = tn;
    tn = new SyntaxTreeNode( mn, N_GenNonExpPrefixOp, heirs );
      break;
    default:
      jj_la1[63] = jj_gen;
      if (jj_2_29(1)) {
        try {
          tn = Expression();
        } catch (ParseException e) {
// RuntimeConfiguration.get().getOutStream().println("Caught exception (bis)");
// first things first - restore evaluation stack
    OperatorStack.popStack();
    /* it wasn't an expression, what was it ? */
    /* check the nature of the node returned. It can only be a prefixed op. */
    if ( ( anchor != null )
       &&( anchor.isKind( N_GenPrefixOp ) || anchor.isKind( N_GenInfixOp ) || anchor.isKind( N_GenPostfixOp ) ) ) {
       tn = anchor; anchor = null;
    } else
       {if (true) throw e;}
        }
      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    addHeir( tn );
  }

  final public SyntaxTreeNode ParenExpr() throws ParseException {
  SyntaxTreeNode zn[] = new SyntaxTreeNode[3];
  SyntaxTreeNode tn;
  Token t;
    t = jj_consume_token(LBR);
               zn[0] = new SyntaxTreeNode(mn, t);
    zn[1] = Expression();
    t = jj_consume_token(RBR);
               zn[2] = new SyntaxTreeNode(mn, t);
    {if (true) return new SyntaxTreeNode(mn, N_ParenExpr, zn );}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode SomeQuant() throws ParseException {
  SyntaxTreeNode tn;
  Token t;
  bpa("Quantified form");
  int kind;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EXISTS:
      t = jj_consume_token(EXISTS);
      break;
    case FORALL:
      t = jj_consume_token(FORALL);
      break;
    default:
      jj_la1[64] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                                    addHeir( new SyntaxTreeNode(mn, t));
    if (jj_2_30(2147483647)) {
      tn = Identifier();
      kind = N_UnboundQuant;
      addHeir( tn );
      label_16:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[65] = jj_gen;
          break label_16;
        }
        t = jj_consume_token(COMMA);
                      addHeir( new SyntaxTreeNode(mn, t) );
        tn = Identifier();
        addHeir( tn );
      }
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LAB:
      case IDENTIFIER:
        tn = QuantBound();
      kind = N_BoundQuant;
      addHeir( tn );
        label_17:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case COMMA:
            ;
            break;
          default:
            jj_la1[66] = jj_gen;
            break label_17;
          }
          t = jj_consume_token(COMMA);
                    addHeir( new SyntaxTreeNode(mn, t) );
          tn = QuantBound();
                          addHeir( tn );
        }
        break;
      default:
        jj_la1[67] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    t = jj_consume_token(COLON);
                 addHeir( new SyntaxTreeNode(mn, t) );
    tn = Expression();
                      addHeir( tn );
    SyntaxTreeNode sn[] = getLastHeirs();
    epa(); {if (true) return new SyntaxTreeNode(mn, kind, sn);}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode SomeTQuant() throws ParseException {
  SyntaxTreeNode tn;
  Token t;
  bpa("Bound Quantified Expression");
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case T_EXISTS:
      t = jj_consume_token(T_EXISTS);
      break;
    case T_FORALL:
      t = jj_consume_token(T_FORALL);
      break;
    default:
      jj_la1[68] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                                        addHeir( new SyntaxTreeNode(mn, t) );
    tn = Identifier();
    addHeir( tn );
    label_18:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[69] = jj_gen;
        break label_18;
      }
      t = jj_consume_token(COMMA);
                  addHeir( new SyntaxTreeNode(mn, t) );
      tn = Identifier();
      addHeir( tn );
    }
    t = jj_consume_token(COLON);
                 addHeir( new SyntaxTreeNode(mn, t) );
    tn = Expression();
                      addHeir( tn );
    SyntaxTreeNode sn[] = getLastHeirs();
    epa(); {if (true) return new SyntaxTreeNode(mn, N_UnboundQuant, sn);}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode QuantBound() throws ParseException {
  SyntaxTreeNode tn;
  Token t;
  bpa("Quant Bound");
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LAB:
      tn = IdentifierTuple();
      addHeir( tn );
      break;
    case IDENTIFIER:
      tn = Identifier();
      addHeir( tn );
      label_19:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[70] = jj_gen;
          break label_19;
        }
        t = jj_consume_token(COMMA);
                      addHeir( new SyntaxTreeNode(mn, t) );
        tn = Identifier();
          addHeir( tn );
          expecting = ", or \\in";
      }
      break;
    default:
      jj_la1[71] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    t = jj_consume_token(IN);
    tn =  new SyntaxTreeNode(mn, t);
    tn.setKind(T_IN);
    addHeir(tn);
    tn = Expression();
                      addHeir( tn );
    SyntaxTreeNode sn[] = getLastHeirs();
    epa(); {if (true) return new SyntaxTreeNode(mn, N_QuantBound, sn);}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode BraceCases() throws ParseException {
  int kind = N_SetEnumerate; // set by default.
  SyntaxTreeNode tn;
  Token t;
  boolean te = false;
  bpa("Some { } form");
    t = jj_consume_token(LBC);
               addHeir( new SyntaxTreeNode(mn, t) );
    if (jj_2_34(1)) {
      if (matchFcnConst()) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LAB:
          tn = IdentifierTuple();
          break;
        case IDENTIFIER:
          tn = Identifier();
          break;
        default:
          jj_la1[72] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      addHeir(tn);
      expecting = "\\in";
        t = jj_consume_token(IN);
      tn =  new SyntaxTreeNode(mn, t);
      tn.setKind(T_IN);
      addHeir(tn);
      kind = N_SubsetOf;
        tn = Expression();
                        addHeir( tn ); expecting = ":";
        t = jj_consume_token(COLON);
                   addHeir( new SyntaxTreeNode(mn, t) );
        tn = Expression();
                        addHeir( tn );
      } else if (jj_2_31(2147483647)) {
        tn = Expression();
      kind = N_SetEnumerate;
      addHeir( tn );
        label_20:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case COMMA:
            ;
            break;
          default:
            jj_la1[73] = jj_gen;
            break label_20;
          }
          t = jj_consume_token(COMMA);
                     addHeir( new SyntaxTreeNode(mn, t) );
          tn = Expression();
                            addHeir( tn );
        }
      } else if (jj_2_32(2147483647)) {
      te = true; kind = N_SetOfAll;
        tn = Expression();
      addHeir( tn );
        t = jj_consume_token(COLON);
                   addHeir( new SyntaxTreeNode(mn, t) );
        tn = QuantBound();
                        addHeir( tn );
        label_21:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case COMMA:
            ;
            break;
          default:
            jj_la1[74] = jj_gen;
            break label_21;
          }
          t = jj_consume_token(COMMA);
                    addHeir( new SyntaxTreeNode(mn, t) );
          tn = QuantBound();
                          addHeir( tn );
        }
      } else if (jj_2_33(1)) {
        tn = Expression();
                        addHeir( tn );
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
        case COLON:
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case COLON:
            t = jj_consume_token(COLON);
        te = true; kind = N_SetOfAll;
// IF tn is infix expression, with operator IN, we have a pbm for throw new ParseException( "Form {a \in b : c \in d } is forbidden" );
        SyntaxTreeNode Hone[] = (SyntaxTreeNode[])tn.heirs();
        Hone = (SyntaxTreeNode[])Hone[1].heirs(); // second heir of second heir
        if ( tn.isKind( N_InfixExpr ) && Hone[1].getImage().equals("\\in") ) {
          {if (true) throw new ParseException( "Form {a \\in b : c \\in d }, at line " + t.beginLine + ", is not allowed" );}
        }
        addHeir( new SyntaxTreeNode(mn, t) );
            tn = QuantBound();
                          addHeir( tn );
            label_22:
            while (true) {
              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
              case COMMA:
                ;
                break;
              default:
                jj_la1[75] = jj_gen;
                break label_22;
              }
              t = jj_consume_token(COMMA);
                      addHeir( new SyntaxTreeNode(mn, t) );
              tn = QuantBound();
                          addHeir( tn );
            }
            break;
          case COMMA:
            label_23:
            while (true) {
              t = jj_consume_token(COMMA);
                      kind = N_SetEnumerate;
        addHeir( new SyntaxTreeNode(mn, t) );
              tn = Expression();
                            addHeir( tn );
              switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
              case COMMA:
                ;
                break;
              default:
                jj_la1[76] = jj_gen;
                break label_23;
              }
            }
            break;
          default:
            jj_la1[77] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          break;
        default:
          jj_la1[78] = jj_gen;
          ;
        }
      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
    } else {
      ;
    }
    t = jj_consume_token(RBC);
    addHeir( new SyntaxTreeNode(mn, t) );
    SyntaxTreeNode sn[] = getLastHeirs();
    epa(); {if (true) return new SyntaxTreeNode(mn, kind, sn);}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode SBracketCases() throws ParseException {
  SyntaxTreeNode tn;
  Token t;
  int kind = 0;
  bpa("Some [] Form");
    t = jj_consume_token(LSB);
               addHeir( new SyntaxTreeNode(mn, t) );
    if (matchFcnConst()) {
      // FcnConst - because we use OpSymbol rather than IN, we need to use semantic detection.
          tn = QuantBound();
      kind = N_FcnConst;
      addHeir( tn );
      label_24:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[79] = jj_gen;
          break label_24;
        }
        t = jj_consume_token(COMMA);
                    addHeir( new SyntaxTreeNode(mn, t) );
        tn = QuantBound();
                          addHeir( tn );
      }
      t = jj_consume_token(MAPTO);
                  addHeir( new SyntaxTreeNode(mn, t) );
      tn = Expression();
                        addHeir( tn );
      t = jj_consume_token(RSB);
                addHeir( new SyntaxTreeNode(mn, t) );
    } else if (jj_2_35(2147483647)) {
      /* RcdConstructor */
          tn = FieldVal();
      kind = N_RcdConstructor;
      addHeir( tn );
      label_25:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[80] = jj_gen;
          break label_25;
        }
        t = jj_consume_token(COMMA);
                    addHeir( new SyntaxTreeNode(mn, t) );
        tn = FieldVal();
                        addHeir( tn );
      }
      t = jj_consume_token(RSB);
                addHeir( new SyntaxTreeNode(mn, t) );
    } else if ((getToken(2).kind == MAPTO) && isFieldNameToken( getToken(1))) {
      getToken(1).kind = IDENTIFIER;
      tn = FieldVal();
      kind = N_RcdConstructor;
      addHeir( tn );
      label_26:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[81] = jj_gen;
          break label_26;
        }
        t = jj_consume_token(COMMA);
                    addHeir( new SyntaxTreeNode(mn, t) );
        tn = FieldVal();
                        addHeir( tn );
      }
      t = jj_consume_token(RSB);
                addHeir( new SyntaxTreeNode(mn, t) );
    } else if (jj_2_36(2147483647)) {
      /* SetOfRcds */
          tn = FieldSet();
      kind = N_SetOfRcds;
      addHeir( tn );
      label_27:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[82] = jj_gen;
          break label_27;
        }
        t = jj_consume_token(COMMA);
                    addHeir( new SyntaxTreeNode(mn, t) );
        tn = FieldSet();
                        addHeir( tn );
      }
      t = jj_consume_token(RSB);
                addHeir( new SyntaxTreeNode(mn, t) );
    } else if (jj_2_37(1)) {
      tn = Expression();
                        addHeir( tn );
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
      case RSB:
        label_28:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case COMMA:
            ;
            break;
          default:
            jj_la1[83] = jj_gen;
            break label_28;
          }
          t = jj_consume_token(COMMA);
                      addHeir( new SyntaxTreeNode(mn, t) );
          tn = Expression();
                            addHeir( tn );
        }
        t = jj_consume_token(RSB);
                  addHeir( new SyntaxTreeNode(mn, t) );
      kind = N_FcnAppl;
      lastOp = FcnOp;
        break;
      case ARROW:
        t = jj_consume_token(ARROW);
                                          // SetOfFcns
        kind = N_SetOfFcns;
        addHeir( new SyntaxTreeNode(mn, t) );
        tn = Expression();
                          addHeir( tn );
        t = jj_consume_token(RSB);
                  addHeir( new SyntaxTreeNode(mn, t) );
        break;
      case EXCEPT:
        t = jj_consume_token(EXCEPT);
                                           // Except
        kind = N_Except;
        addHeir( new SyntaxTreeNode(mn, t) );
        tn = ExceptSpec();
                          addHeir( tn );
        label_29:
        while (true) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case COMMA:
            ;
            break;
          default:
            jj_la1[84] = jj_gen;
            break label_29;
          }
          t = jj_consume_token(COMMA);
                      addHeir( new SyntaxTreeNode(mn, t) );
          tn = ExceptSpec();
                            addHeir( tn );
        }
        t = jj_consume_token(RSB);
                  addHeir( new SyntaxTreeNode(mn, t) );
        break;
      case ARSB:
        t = jj_consume_token(ARSB);
        kind = N_ActionExpr;
        addHeir( new SyntaxTreeNode(mn, t) );
        tn = ReducedExpression();
                                 addHeir( tn );
        break;
      default:
        jj_la1[85] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
    SyntaxTreeNode sn[] = getLastHeirs();
    Assert.assertion(kind !=0);
    epa(); {if (true) return new SyntaxTreeNode(mn, kind, sn);}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode FieldVal() throws ParseException {
  SyntaxTreeNode zn[] = new SyntaxTreeNode[3];
  Token t;
  bpa("Field Value");
    zn[0] = Identifier();
    t = jj_consume_token(MAPTO);
                zn[1] = new SyntaxTreeNode(mn, t);
    zn[2] = Expression();
    epa(); {if (true) return new SyntaxTreeNode(mn, N_FieldVal, zn );}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode FieldSet() throws ParseException {
  SyntaxTreeNode zn[] = new SyntaxTreeNode[3];
  SyntaxTreeNode tn;
  Token t;
  bpa("Field Set");
    zn[0] = Identifier();
    t = jj_consume_token(COLON);
                zn[1] = new SyntaxTreeNode(mn, t);
    zn[2] = Expression();
    epa(); {if (true) return new SyntaxTreeNode( mn, N_FieldSet, zn );}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode ExceptSpec() throws ParseException {
  SyntaxTreeNode tn;
  Token t;
  bpa("Except Spec");
    t = jj_consume_token(BANG);
               addHeir( new SyntaxTreeNode(mn, t) );
    label_30:
    while (true) {
      tn = ExceptComponent();
    addHeir( tn );
    expecting = "= or ,";
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DOT:
      case LSB:
        ;
        break;
      default:
        jj_la1[86] = jj_gen;
        break label_30;
      }
    }
    t = jj_consume_token(EQUALS);
    tn =  new SyntaxTreeNode(mn, t);
    tn.setKind(T_EQUAL);
    addHeir(tn);
    tn = Expression();
                      addHeir( tn );
    SyntaxTreeNode sn[] = getLastHeirs();
    epa(); {if (true) return new SyntaxTreeNode( mn, N_ExceptSpec, sn );}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode ExceptComponent() throws ParseException {
  SyntaxTreeNode tn;
  Token t;
  bpa("Except Component");
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DOT:
      t = jj_consume_token(DOT);
                addHeir( new SyntaxTreeNode(mn, t) );
      tn = Identifier();
      if (tn.getUS().equals(At) ) {
        PErrors.push( new ParseError("@ used in !.@") );
      }
      addHeir( tn );
      break;
    case LSB:
      t = jj_consume_token(LSB);
                addHeir( new SyntaxTreeNode(mn, t) );
      tn = Expression();
                        addHeir( tn );
      label_31:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[87] = jj_gen;
          break label_31;
        }
        t = jj_consume_token(COMMA);
                    addHeir( new SyntaxTreeNode(mn, t) );
        tn = Expression();
                          addHeir( tn );
      }
      t = jj_consume_token(RSB);
                addHeir( new SyntaxTreeNode(mn, t) );
      break;
    default:
      jj_la1[88] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    SyntaxTreeNode sn[] = getLastHeirs(); epa();
    {if (true) return new SyntaxTreeNode( mn, N_ExceptComponent, sn );}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode SetExcept() throws ParseException {
  SyntaxTreeNode tn;
  Token t;
  bpa("Set Except");
    t = jj_consume_token(LWB);
              addHeir( new SyntaxTreeNode(mn, t) );
    tn = Expression();
                      addHeir( tn );
    t = jj_consume_token(EXCEPT);
                 addHeir( new SyntaxTreeNode(mn, t) );
    tn = SExceptSpec();
                       addHeir( tn );
    label_32:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[89] = jj_gen;
        break label_32;
      }
      t = jj_consume_token(COMMA);
                  addHeir( new SyntaxTreeNode(mn, t) );
      tn = SExceptSpec();
                         addHeir( tn );
    }
    t = jj_consume_token(RWB);
              addHeir( new SyntaxTreeNode(mn, t) );
    SyntaxTreeNode sn[] = getLastHeirs();
    epa(); {if (true) return new SyntaxTreeNode( mn, N_SetExcept, sn );}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode SExceptSpec() throws ParseException {
  SyntaxTreeNode zn[] = new SyntaxTreeNode[4];
  SyntaxTreeNode tn;
  Token t;
  bpa("Set Expect Spec");
    t = jj_consume_token(BANG);
               zn[0] = new SyntaxTreeNode(mn, t);
    zn[1] = ExceptComponent();
    expecting = "= or \\in";
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EQUALS:
      t = jj_consume_token(EQUALS);
      zn[2] =  new SyntaxTreeNode(mn, t); zn[2].setKind( T_EQUAL );
      break;
    case IN:
      t = jj_consume_token(IN);
      zn[2] =  new SyntaxTreeNode(mn, t); zn[2].setKind( T_IN );
      break;
    default:
      jj_la1[90] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    zn[3] = Expression();
    epa(); {if (true) return new SyntaxTreeNode( mn, N_SExceptSpec, zn );}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode TupleOrAction() throws ParseException {
  int kind = 0;
  SyntaxTreeNode tn;
  Token t;
  bpa("Some << -- >> or >>_ Form");
    t = jj_consume_token(LAB);
              addHeir( new SyntaxTreeNode(mn, t) );
    if (jj_2_38(1)) {
      tn = Expression();
                        addHeir( tn );
      label_33:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[91] = jj_gen;
          break label_33;
        }
        t = jj_consume_token(COMMA);
                    addHeir( new SyntaxTreeNode(mn, t) );
        tn = Expression();
                            addHeir( tn );
      }
    } else {
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case RAB:
      t = jj_consume_token(RAB);
      kind = N_Tuple; addHeir( new SyntaxTreeNode(mn, t) );
      break;
    case ARAB:
      t = jj_consume_token(ARAB);
      kind = N_ActionExpr; addHeir( new SyntaxTreeNode(mn, t) );
      tn = ReducedExpression();
                               addHeir( tn );
      break;
    default:
      jj_la1[92] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    SyntaxTreeNode sn[] = getLastHeirs();
    epa(); {if (true) return new SyntaxTreeNode( mn, kind, sn );}
    throw new Error("Missing return statement in function");
  }

//  new SyntaxTreeNode( N_IdPrefix )  ???
  final public SyntaxTreeNode NoOpExtension() throws ParseException {
  SyntaxTreeNode tid, top, last;
  last = null; top = null;
  Token t = null;
    tid = Identifier();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LBR:
      top = OpArgs();
      break;
    default:
      jj_la1[93] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BANG:
      t = jj_consume_token(BANG);
        SyntaxTreeNode heirs[];
        if ( top == null ) {
          heirs = new SyntaxTreeNode[2];
          heirs[1] = new SyntaxTreeNode( mn, t );
        } else {
          heirs = new SyntaxTreeNode[3];
          heirs[1] = top;
          heirs[2] = new SyntaxTreeNode(mn, t );
        }
        heirs[0] = tid;
        SyntaxTreeNode current = new SyntaxTreeNode( mn, N_IdPrefixElement, heirs );
        addHeir( current );
      last = NoOpExtension();
      break;
    default:
      jj_la1[94] = jj_gen;
      ;
    }
      if ( last == null ) { // means no bang, bottom of recursion
         if ( top != null )
           FairnessHook = top;
         else
           FairnessHook = null;
         SyntaxTreeNode zn[] = new SyntaxTreeNode[2];
         zn[0] = new SyntaxTreeNode( mn, N_IdPrefix, getLastHeirs() );
         zn[1] = tid;
         last = new SyntaxTreeNode( mn, N_GeneralId, zn );
      }
    {if (true) return last;}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode ReducedExpression() throws ParseException {
  SyntaxTreeNode expr;
  bpa("restricted form of expression");
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
      expr = NoOpExtension();
      break;
    case LBR:
      expr = ParenExpr();
      break;
    case LBC:
      expr = BraceCases();
      break;
    case LSB:
      expr = SBracketCases();
      break;
    case LWB:
      expr = SetExcept();
      break;
    case LAB:
      expr = TupleOrAction();
      break;
    default:
      jj_la1[95] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     epa(); {if (true) return expr;}
    throw new Error("Missing return statement in function");
  }

// The following cases - for the first expression - must be recognized :
// "GeneralId", "OpApplication", "RecordComponent", "FcnAppl", "ParenExpr", "SetEnumerate", "SubsetOf", "SetOfAll", "FcnConst", "SetOfFcns", "RcdConstructor", "SetOfRcds", "Except", "Tuple", "ActionExpr"
// The cases break down in two categories: two set of () or a single one.
// in general, it's going to be some () [] or {} expression, or an Identifier foollowed by . () or [].
// Note that FcnAppl may be more intricate.
  final public SyntaxTreeNode FairnessExpr() throws ParseException {
  SyntaxTreeNode zn[] = new SyntaxTreeNode[5];
  SyntaxTreeNode tn, expr;
  Token t;
  FairnessHook = null;
  bpa("Fairness Expression");
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WF:
      t = jj_consume_token(WF);
      break;
    case SF:
      t = jj_consume_token(SF);
      break;
    default:
      jj_la1[96] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                          zn[0] = new SyntaxTreeNode(mn, t);
    expr = ReducedExpression();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LBR:
      t = jj_consume_token(LBR);
    zn[1] = expr; expr = null;
    zn[2] = new SyntaxTreeNode(mn, t);
      zn[3] = Expression();
      t = jj_consume_token(RBR);
                zn[4] = new SyntaxTreeNode(mn, t);
      break;
    default:
      jj_la1[97] = jj_gen;
      ;
    }
    epa();
    if ( expr != null ) {  // no extra (), FairnessHook can't be null ** Add check.
      if (FairnessHook == null) {
        {if (true) throw new ParseException("Ill-structured fairness expression at line " + zn[0].location[0] + ", column " + zn[0].location[1]);}
      }

      SyntaxTreeNode parameters[] = (SyntaxTreeNode[]) FairnessHook.heirs();
      if ( parameters != null && parameters.length == 3) { // was FairnessHook
        zn[1] = expr;
        zn[2] = parameters[0];
        zn[3] = parameters[1];
        zn[4] = parameters[2];
      } else {
        PErrors.push( new ParseError("Error in fairness expression at " + zn[0].location[0] + ": " + zn[0].location[1] + "\n", "-- --") );
        {if (true) return expr;}
      }
// left for level checking.
//      if ( expr.isKind( N_ActionExpr ) ) {
//        PErrors.push( new ParseError("Error in fairness expression at " + zn[0].location[0] + ": " + zn[0].location[1] + ": use of an action form\n", "-- --") );
//        return expr;
//      }
    } else { // reattach FairnessHook ! unless it is tuple
// "GeneralId", "RecordComponent", "FcnAppl",
      if ( zn[1].isKind( N_GeneralId ) &&  FairnessHook != null ) {
        SyntaxTreeNode ozn[] = new SyntaxTreeNode[2];
        ozn[0] = zn[1];
        ozn[1] = FairnessHook;
        zn[1] = new SyntaxTreeNode( mn, N_OpApplication, ozn );
      } else if ( ! (zn[1].isKind( N_Tuple )|| zn[1].isKind( N_ParenExpr ) || zn[1].isKind( N_SetEnumerate )|| zn[1].isKind( N_SubsetOf )|| zn[1].isKind( N_SetOfAll )|| zn[1].isKind( N_SetOfFcns )|| zn[1].isKind( N_RcdConstructor )|| zn[1].isKind( N_SetOfRcds )|| zn[1].isKind( N_Except )|| zn[1].isKind( N_FcnConst )|| zn[1].isKind( N_ActionExpr )) ){
// "ParenExpr", "SetEnumerate", "SubsetOf", "SetOfAll", "FcnConst",
// "SetOfFcns", "RcdConstructor", "SetOfRcds", "Except",
// "Tuple", "ActionExpr"
        PErrors.push( new ParseError("Error in fairness expression at " + zn[0].location[0] + ": " + zn[0].location[1] + ": could not link arguments\n", "-- --") );
        {if (true) return zn[1];}
      }
    }
    {if (true) return new SyntaxTreeNode( mn, N_FairnessExpr, zn );}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode IfThenElse() throws ParseException {
  SyntaxTreeNode zn[] = new SyntaxTreeNode[6];
  Token t;
  bpa("IF THEN ELSE");
    t = jj_consume_token(IF);
               zn[0] = new SyntaxTreeNode(mn, t);
    zn[1] = Expression();
    t = jj_consume_token(THEN);
               zn[2] =  new SyntaxTreeNode(mn, t);
    zn[3] = Expression();
    t = jj_consume_token(ELSE);
               zn[4] =  new SyntaxTreeNode(mn, t);
    zn[5] = Expression();
    epa(); {if (true) return new SyntaxTreeNode(mn, N_IfThenElse, zn);}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode Case() throws ParseException {
  SyntaxTreeNode tn;
  Token t;
  bpa("CASE Expression");
    t = jj_consume_token(CASE);
               addHeir( new SyntaxTreeNode(mn, t) );
    tn = CaseArm();
                   addHeir( tn );
    label_34:
    while (true) {
      if (caseSep() && (getToken(2).kind != OTHER)) {
        ;
      } else {
        break label_34;
      }
      t = jj_consume_token(CASESEP);
                    addHeir( new SyntaxTreeNode(mn, t) );
      tn = CaseArm();
                     addHeir( tn );
    }
    if (caseSep()) {
      t = jj_consume_token(CASESEP);
                    addHeir( new SyntaxTreeNode(mn, t) );
      tn = OtherArm();
                      addHeir( tn );
    } else {
      ;
    }
    SyntaxTreeNode sn[] = getLastHeirs();
    epa(); {if (true) return new SyntaxTreeNode(mn, N_Case, sn);}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode CaseArm() throws ParseException {
  SyntaxTreeNode zn[] = new SyntaxTreeNode[3];
  Token t;
  bpa("Case Arm");
    zn[0] = Expression();
    t = jj_consume_token(ARROW);
                zn[1] = new SyntaxTreeNode(mn, t);
    zn[2] = Expression();
    epa(); {if (true) return new SyntaxTreeNode( mn, N_CaseArm, zn );}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode OtherArm() throws ParseException {
  SyntaxTreeNode zn[] = new SyntaxTreeNode[3];
  Token t;
  bpa("Case Other Arm");
    t = jj_consume_token(OTHER);
                zn[0] = new SyntaxTreeNode(mn, t);
    t = jj_consume_token(ARROW);
                zn[1] = new SyntaxTreeNode(mn, t);
    zn[2] = Expression();
    epa(); {if (true) return new SyntaxTreeNode( mn, N_OtherArm, zn );}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode LetIn() throws ParseException {
  SyntaxTreeNode zn[] = new SyntaxTreeNode[4];
  SyntaxTreeNode tn;
  Token t;
  bpa("Case Other Arm");
    t = jj_consume_token(LET);
              zn[0] = new SyntaxTreeNode(mn, t);
    zn[1] = LetDefinitions();
    t = jj_consume_token(LETIN);
                zn[2] = new SyntaxTreeNode(mn, t);
    zn[3] = Expression();
    epa(); {if (true) return new SyntaxTreeNode( mn, N_LetIn, zn );}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode LetDefinitions() throws ParseException {
  SyntaxTreeNode tn;
  Token t;
  bpa("Let Definitions");
    label_35:
    while (true) {
      tn = OperatorOrFunctionDefinition();
                                          addHeir( tn );
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LOCAL:
      case DEFBREAK:
        ;
        break;
      default:
        jj_la1[98] = jj_gen;
        break label_35;
      }
    }
    SyntaxTreeNode sn[] = getLastHeirs();
    epa(); {if (true) return new SyntaxTreeNode(mn, N_LetDefinitions, sn);}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode Junctions() throws ParseException {
  BStack.newReference(getToken(1).endColumn, getToken(1).kind);
  bpa("AND-OR Junction");
  int kind;
    if (jj_2_39(2147483647)) {
                                kind = N_DisjList;
      DisjList();
    } else if (jj_2_40(2147483647)) {
                                 kind = N_ConjList;
      ConjList();
    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
    BStack.popReference();
    SyntaxTreeNode sn[] = getLastHeirs();
    epa(); {if (true) return new SyntaxTreeNode( mn, kind, sn);}
    throw new Error("Missing return statement in function");
  }

  final public void DisjList() throws ParseException {
  SyntaxTreeNode tn;
    tn = JuncItem(N_DisjItem);
    addHeir(tn);
    label_36:
    while (true) {
      if (BStack.onReference( getToken(1).endColumn, getToken(1).kind )) {
        ;
      } else {
        break label_36;
      }
      tn = JuncItem(N_DisjItem);
                                 addHeir(tn);
    }
  }

  final public void ConjList() throws ParseException {
  SyntaxTreeNode tn;
    tn = JuncItem(N_ConjItem);
    addHeir( tn );
    label_37:
    while (true) {
      if (BStack.onReference( getToken(1).endColumn, getToken(1).kind )) {
        ;
      } else {
        break label_37;
      }
      tn = JuncItem(N_ConjItem);
                                 addHeir( tn );
    }
  }

  final public SyntaxTreeNode JuncItem(int itemKind) throws ParseException {
  SyntaxTreeNode zn[] = new SyntaxTreeNode[2];
  SyntaxTreeNode tn;
  Token t;
  bpa("Junction Item");
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BOR:
      t = jj_consume_token(BOR);
      break;
    case OR:
      t = jj_consume_token(OR);
      break;
    case AND:
      t = jj_consume_token(AND);
      break;
    case BAND:
      t = jj_consume_token(BAND);
      break;
    default:
      jj_la1[99] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    zn[0] = new SyntaxTreeNode(mn, t);
    zn[1] = Expression();
    epa(); {if (true) return new SyntaxTreeNode( mn, itemKind, zn );}
    throw new Error("Missing return statement in function");
  }

  final public SyntaxTreeNode UnboundOrBoundChoose() throws ParseException {
  SyntaxTreeNode zn[] = new SyntaxTreeNode[5];
  SyntaxTreeNode tn;
  Token t;
  bpa("(Un)Bounded Choose");
    t = jj_consume_token(CHOOSE);
                 zn[0] = new SyntaxTreeNode(mn, t);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
      zn[1] = Identifier();
      break;
    case LAB:
      zn[1] = IdentifierTuple();
      break;
    default:
      jj_la1[100] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    zn[2] = MaybeBound();
    t = jj_consume_token(COLON);
                zn[3] = new SyntaxTreeNode(mn, t);
    zn[4] = Expression();
    SyntaxTreeNode sn[] = getLastHeirs();
    epa(); {if (true) return new SyntaxTreeNode( mn, N_UnboundOrBoundChoose, zn);}
    throw new Error("Missing return statement in function");
  }

// boxDisc (riminate) uses preInEmptyTop
// note that junction is processed separately.
  final public SyntaxTreeNode Expression() throws ParseException {
  SyntaxTreeNode tn;
  Token t;
  OperatorStack.newStack();
    if (jj_2_44(2147483647) && (BStack.aboveReference( getToken(1).beginColumn))) {
      tn = OpenExpression();
                           OperatorStack.pushOnStack( tn, null );
    } else if (jj_2_45(1)) {
      label_38:
      while (true) {
        if (jj_2_41(2147483647) && (OperatorStack.preInEmptyTop() && BStack.aboveReference( getToken(1).beginColumn))) {
          tn = Junctions();
                       OperatorStack.pushOnStack( tn, null );
        } else if (ClosedStart( getToken(1)) && boxDisc() && BStack.aboveReference( getToken(1).beginColumn)) {
          tn = ClosedExpressionOrOp();
       anchor = tn; // XXX is this correct ? Why had it disappered ?
       if ( isGenOp( tn ) ) {
         OperatorStack.pushOnStack( tn, lastOp );
         OperatorStack.reduceStack();
       } else OperatorStack.pushOnStack( tn, null );
        } else {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case DOT:
            t = jj_consume_token(DOT);
     Token next = getToken(1);
     if (isFieldNameToken( next )) next.kind = IDENTIFIER;
            tn = Identifier();
      OperatorStack.reduceRecord(  new SyntaxTreeNode(mn, t) , tn );
            break;
          default:
            jj_la1[101] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
        if (jj_2_42(1)) {
          ;
        } else {
          break label_38;
        }
      }
      if (jj_2_43(2147483647) && (BStack.aboveReference( getToken(1).beginColumn))) {
        tn = OpenExpression();
                            OperatorStack.pushOnStack( tn, null );
      } else {
        ;
      }
    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
   tn = OperatorStack.finalReduce();
   if (tn==null) {if (true) throw new ParseException( " Couldn't reduce expression stack.");}
   OperatorStack.popStack();
   {if (true) return tn;}
    throw new Error("Missing return statement in function");
  }

/* Obsolete
void
ClosedStart() : {
}{
  <IDENTIFIER> | <STRING_LITERAL> | <NUMBER_LITERAL> | <LBR> | <LSB> | <LAB> | <LBC> | <LWB> | <OpSymbol> | <OR> | <AND> | <WF> | <SF>
}
*/
  final public void OpenStart() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CASE:
      jj_consume_token(CASE);
      break;
    case CHOOSE:
      jj_consume_token(CHOOSE);
      break;
    case EXISTS:
      jj_consume_token(EXISTS);
      break;
    case FORALL:
      jj_consume_token(FORALL);
      break;
    case IF:
      jj_consume_token(IF);
      break;
    case LET:
      jj_consume_token(LET);
      break;
    case T_EXISTS:
      jj_consume_token(T_EXISTS);
      break;
    case T_FORALL:
      jj_consume_token(T_FORALL);
      break;
    default:
      jj_la1[102] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_1();
    jj_save(0, xla);
    return retval;
  }

  final private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_2();
    jj_save(1, xla);
    return retval;
  }

  final private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_3();
    jj_save(2, xla);
    return retval;
  }

  final private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_4();
    jj_save(3, xla);
    return retval;
  }

  final private boolean jj_2_5(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_5();
    jj_save(4, xla);
    return retval;
  }

  final private boolean jj_2_6(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_6();
    jj_save(5, xla);
    return retval;
  }

  final private boolean jj_2_7(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_7();
    jj_save(6, xla);
    return retval;
  }

  final private boolean jj_2_8(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_8();
    jj_save(7, xla);
    return retval;
  }

  final private boolean jj_2_9(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_9();
    jj_save(8, xla);
    return retval;
  }

  final private boolean jj_2_10(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_10();
    jj_save(9, xla);
    return retval;
  }

  final private boolean jj_2_11(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_11();
    jj_save(10, xla);
    return retval;
  }

  final private boolean jj_2_12(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_12();
    jj_save(11, xla);
    return retval;
  }

  final private boolean jj_2_13(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_13();
    jj_save(12, xla);
    return retval;
  }

  final private boolean jj_2_14(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_14();
    jj_save(13, xla);
    return retval;
  }

  final private boolean jj_2_15(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_15();
    jj_save(14, xla);
    return retval;
  }

  final private boolean jj_2_16(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_16();
    jj_save(15, xla);
    return retval;
  }

  final private boolean jj_2_17(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_17();
    jj_save(16, xla);
    return retval;
  }

  final private boolean jj_2_18(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_18();
    jj_save(17, xla);
    return retval;
  }

  final private boolean jj_2_19(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_19();
    jj_save(18, xla);
    return retval;
  }

  final private boolean jj_2_20(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_20();
    jj_save(19, xla);
    return retval;
  }

  final private boolean jj_2_21(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_21();
    jj_save(20, xla);
    return retval;
  }

  final private boolean jj_2_22(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_22();
    jj_save(21, xla);
    return retval;
  }

  final private boolean jj_2_23(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_23();
    jj_save(22, xla);
    return retval;
  }

  final private boolean jj_2_24(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_24();
    jj_save(23, xla);
    return retval;
  }

  final private boolean jj_2_25(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_25();
    jj_save(24, xla);
    return retval;
  }

  final private boolean jj_2_26(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_26();
    jj_save(25, xla);
    return retval;
  }

  final private boolean jj_2_27(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_27();
    jj_save(26, xla);
    return retval;
  }

  final private boolean jj_2_28(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_28();
    jj_save(27, xla);
    return retval;
  }

  final private boolean jj_2_29(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_29();
    jj_save(28, xla);
    return retval;
  }

  final private boolean jj_2_30(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_30();
    jj_save(29, xla);
    return retval;
  }

  final private boolean jj_2_31(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_31();
    jj_save(30, xla);
    return retval;
  }

  final private boolean jj_2_32(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_32();
    jj_save(31, xla);
    return retval;
  }

  final private boolean jj_2_33(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_33();
    jj_save(32, xla);
    return retval;
  }

  final private boolean jj_2_34(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_34();
    jj_save(33, xla);
    return retval;
  }

  final private boolean jj_2_35(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_35();
    jj_save(34, xla);
    return retval;
  }

  final private boolean jj_2_36(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_36();
    jj_save(35, xla);
    return retval;
  }

  final private boolean jj_2_37(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_37();
    jj_save(36, xla);
    return retval;
  }

  final private boolean jj_2_38(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_38();
    jj_save(37, xla);
    return retval;
  }

  final private boolean jj_2_39(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_39();
    jj_save(38, xla);
    return retval;
  }

  final private boolean jj_2_40(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_40();
    jj_save(39, xla);
    return retval;
  }

  final private boolean jj_2_41(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_41();
    jj_save(40, xla);
    return retval;
  }

  final private boolean jj_2_42(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_42();
    jj_save(41, xla);
    return retval;
  }

  final private boolean jj_2_43(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_43();
    jj_save(42, xla);
    return retval;
  }

  final private boolean jj_2_44(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_44();
    jj_save(43, xla);
    return retval;
  }

  final private boolean jj_2_45(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    boolean retval = !jj_3_45();
    jj_save(44, xla);
    return retval;
  }

  final private boolean jj_3R_107() {
    if (jj_scan_token(op_12)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_367() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_386()) {
    jj_scanpos = xsp;
    if (jj_3R_387()) {
    jj_scanpos = xsp;
    if (jj_3R_388()) {
    jj_scanpos = xsp;
    if (jj_3R_389()) {
    jj_scanpos = xsp;
    if (jj_3R_390()) {
    jj_scanpos = xsp;
    if (jj_3R_391()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_106() {
    if (jj_scan_token(op_11)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_105() {
    if (jj_scan_token(op_10)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_104() {
    if (jj_scan_token(op_9)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_103() {
    if (jj_scan_token(op_8)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_102() {
    if (jj_scan_token(op_7)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_101() {
    if (jj_scan_token(op_6)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_100() {
    if (jj_scan_token(OR)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_86() {
    if (jj_3R_228()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_99() {
    if (jj_scan_token(op_4)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_98() {
    if (jj_scan_token(op_3)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_97() {
    if (jj_scan_token(AND)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_96() {
    if (jj_scan_token(op_1)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_45() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_96()) {
    jj_scanpos = xsp;
    if (jj_3R_97()) {
    jj_scanpos = xsp;
    if (jj_3R_98()) {
    jj_scanpos = xsp;
    if (jj_3R_99()) {
    jj_scanpos = xsp;
    if (jj_3R_100()) {
    jj_scanpos = xsp;
    if (jj_3R_101()) {
    jj_scanpos = xsp;
    if (jj_3R_102()) {
    jj_scanpos = xsp;
    if (jj_3R_103()) {
    jj_scanpos = xsp;
    if (jj_3R_104()) {
    jj_scanpos = xsp;
    if (jj_3R_105()) {
    jj_scanpos = xsp;
    if (jj_3R_106()) {
    jj_scanpos = xsp;
    if (jj_3R_107()) {
    jj_scanpos = xsp;
    if (jj_3R_108()) {
    jj_scanpos = xsp;
    if (jj_3R_109()) {
    jj_scanpos = xsp;
    if (jj_3R_110()) {
    jj_scanpos = xsp;
    if (jj_3R_111()) {
    jj_scanpos = xsp;
    if (jj_3R_112()) {
    jj_scanpos = xsp;
    if (jj_3R_113()) {
    jj_scanpos = xsp;
    if (jj_3R_114()) {
    jj_scanpos = xsp;
    if (jj_3R_115()) {
    jj_scanpos = xsp;
    if (jj_3R_116()) {
    jj_scanpos = xsp;
    if (jj_3R_117()) {
    jj_scanpos = xsp;
    if (jj_3R_118()) {
    jj_scanpos = xsp;
    if (jj_3R_119()) {
    jj_scanpos = xsp;
    if (jj_3R_120()) {
    jj_scanpos = xsp;
    if (jj_3R_121()) {
    jj_scanpos = xsp;
    if (jj_3R_122()) {
    jj_scanpos = xsp;
    if (jj_3R_123()) {
    jj_scanpos = xsp;
    if (jj_3R_124()) {
    jj_scanpos = xsp;
    if (jj_3R_125()) {
    jj_scanpos = xsp;
    if (jj_3R_126()) {
    jj_scanpos = xsp;
    if (jj_3R_127()) {
    jj_scanpos = xsp;
    if (jj_3R_128()) {
    jj_scanpos = xsp;
    if (jj_3R_129()) {
    jj_scanpos = xsp;
    if (jj_3R_130()) {
    jj_scanpos = xsp;
    if (jj_3R_131()) {
    jj_scanpos = xsp;
    if (jj_3R_132()) {
    jj_scanpos = xsp;
    if (jj_3R_133()) {
    jj_scanpos = xsp;
    if (jj_3R_134()) {
    jj_scanpos = xsp;
    if (jj_3R_135()) {
    jj_scanpos = xsp;
    if (jj_3R_136()) {
    jj_scanpos = xsp;
    if (jj_3R_137()) {
    jj_scanpos = xsp;
    if (jj_3R_138()) {
    jj_scanpos = xsp;
    if (jj_3R_139()) {
    jj_scanpos = xsp;
    if (jj_3R_140()) {
    jj_scanpos = xsp;
    if (jj_3R_141()) {
    jj_scanpos = xsp;
    if (jj_3R_142()) {
    jj_scanpos = xsp;
    if (jj_3R_143()) {
    jj_scanpos = xsp;
    if (jj_3R_144()) {
    jj_scanpos = xsp;
    if (jj_3R_145()) {
    jj_scanpos = xsp;
    if (jj_3R_146()) {
    jj_scanpos = xsp;
    if (jj_3R_147()) {
    jj_scanpos = xsp;
    if (jj_3R_148()) {
    jj_scanpos = xsp;
    if (jj_3R_149()) {
    jj_scanpos = xsp;
    if (jj_3R_150()) {
    jj_scanpos = xsp;
    if (jj_3R_151()) {
    jj_scanpos = xsp;
    if (jj_3R_152()) {
    jj_scanpos = xsp;
    if (jj_3R_153()) {
    jj_scanpos = xsp;
    if (jj_3R_154()) {
    jj_scanpos = xsp;
    if (jj_3R_155()) {
    jj_scanpos = xsp;
    if (jj_3R_156()) {
    jj_scanpos = xsp;
    if (jj_3R_157()) {
    jj_scanpos = xsp;
    if (jj_3R_158()) {
    jj_scanpos = xsp;
    if (jj_3R_159()) {
    jj_scanpos = xsp;
    if (jj_3R_160()) {
    jj_scanpos = xsp;
    if (jj_3R_161()) {
    jj_scanpos = xsp;
    if (jj_3R_162()) {
    jj_scanpos = xsp;
    if (jj_3R_163()) {
    jj_scanpos = xsp;
    if (jj_3R_164()) {
    jj_scanpos = xsp;
    if (jj_3R_165()) {
    jj_scanpos = xsp;
    if (jj_3R_166()) {
    jj_scanpos = xsp;
    if (jj_3R_167()) {
    jj_scanpos = xsp;
    if (jj_3R_168()) {
    jj_scanpos = xsp;
    if (jj_3R_169()) {
    jj_scanpos = xsp;
    if (jj_3R_170()) {
    jj_scanpos = xsp;
    if (jj_3R_171()) {
    jj_scanpos = xsp;
    if (jj_3R_172()) {
    jj_scanpos = xsp;
    if (jj_3R_173()) {
    jj_scanpos = xsp;
    if (jj_3R_174()) {
    jj_scanpos = xsp;
    if (jj_3R_175()) {
    jj_scanpos = xsp;
    if (jj_3R_176()) {
    jj_scanpos = xsp;
    if (jj_3R_177()) {
    jj_scanpos = xsp;
    if (jj_3R_178()) {
    jj_scanpos = xsp;
    if (jj_3R_179()) {
    jj_scanpos = xsp;
    if (jj_3R_180()) {
    jj_scanpos = xsp;
    if (jj_3R_181()) {
    jj_scanpos = xsp;
    if (jj_3R_182()) {
    jj_scanpos = xsp;
    if (jj_3R_183()) {
    jj_scanpos = xsp;
    if (jj_3R_184()) {
    jj_scanpos = xsp;
    if (jj_3R_185()) {
    jj_scanpos = xsp;
    if (jj_3R_186()) {
    jj_scanpos = xsp;
    if (jj_3R_187()) {
    jj_scanpos = xsp;
    if (jj_3R_188()) {
    jj_scanpos = xsp;
    if (jj_3R_189()) {
    jj_scanpos = xsp;
    if (jj_3R_190()) {
    jj_scanpos = xsp;
    if (jj_3R_191()) {
    jj_scanpos = xsp;
    if (jj_3R_192()) {
    jj_scanpos = xsp;
    if (jj_3R_193()) {
    jj_scanpos = xsp;
    if (jj_3R_194()) {
    jj_scanpos = xsp;
    if (jj_3R_195()) {
    jj_scanpos = xsp;
    if (jj_3R_196()) {
    jj_scanpos = xsp;
    if (jj_3R_197()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_19() {
    if (jj_3R_49()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(DEF)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_84() {
    if (jj_scan_token(THEOREM)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_83() {
    if (jj_scan_token(LOCAL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_41() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_83()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    xsp = jj_scanpos;
    if (jj_3R_84()) {
    jj_scanpos = xsp;
    if (jj_3R_85()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    xsp = jj_scanpos;
    if (jj_3_19()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    xsp = jj_scanpos;
    if (jj_3R_86()) {
    jj_scanpos = xsp;
    if (jj_3_20()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_271() {
    if (jj_scan_token(op_116)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_270() {
    if (jj_scan_token(op_115)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_269() {
    if (jj_scan_token(op_114)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_268() {
    if (jj_scan_token(op_113)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_267() {
    if (jj_scan_token(op_112)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_266() {
    if (jj_scan_token(op_76)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_265() {
    if (jj_scan_token(op_61)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_264() {
    if (jj_scan_token(CASESEP)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_263() {
    if (jj_scan_token(op_58)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_262() {
    if (jj_scan_token(op_29)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_261() {
    if (jj_scan_token(op_26)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_414() {
    if (jj_scan_token(BANG)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_404()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_244() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_261()) {
    jj_scanpos = xsp;
    if (jj_3R_262()) {
    jj_scanpos = xsp;
    if (jj_3R_263()) {
    jj_scanpos = xsp;
    if (jj_3R_264()) {
    jj_scanpos = xsp;
    if (jj_3R_265()) {
    jj_scanpos = xsp;
    if (jj_3R_266()) {
    jj_scanpos = xsp;
    if (jj_3R_267()) {
    jj_scanpos = xsp;
    if (jj_3R_268()) {
    jj_scanpos = xsp;
    if (jj_3R_269()) {
    jj_scanpos = xsp;
    if (jj_3R_270()) {
    jj_scanpos = xsp;
    if (jj_3R_271()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_413() {
    if (jj_3R_238()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_351() {
    if (jj_scan_token(IN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_43()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_345() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_351()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_404() {
    if (jj_3R_49()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_413()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    xsp = jj_scanpos;
    if (jj_3R_414()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_335() {
    if (jj_scan_token(op_116)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_334() {
    if (jj_scan_token(op_115)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_333() {
    if (jj_scan_token(op_114)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_332() {
    if (jj_scan_token(op_113)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_331() {
    if (jj_scan_token(op_112)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_330() {
    if (jj_scan_token(op_61)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_329() {
    if (jj_scan_token(CASESEP)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_328() {
    if (jj_scan_token(op_58)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_253() {
    if (jj_3R_40()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_327() {
    if (jj_scan_token(op_29)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_18() {
    if (jj_3R_39()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_326() {
    if (jj_scan_token(op_26)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_325() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_326()) {
    jj_scanpos = xsp;
    if (jj_3R_327()) {
    jj_scanpos = xsp;
    if (jj_3R_328()) {
    jj_scanpos = xsp;
    if (jj_3R_329()) {
    jj_scanpos = xsp;
    if (jj_3R_330()) {
    jj_scanpos = xsp;
    if (jj_3R_331()) {
    jj_scanpos = xsp;
    if (jj_3R_332()) {
    jj_scanpos = xsp;
    if (jj_3R_333()) {
    jj_scanpos = xsp;
    if (jj_3R_334()) {
    jj_scanpos = xsp;
    if (jj_3R_335()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_252() {
    if (jj_3R_279()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_366() {
    if (jj_scan_token(ARAB)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_367()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_251() {
    if (jj_3R_278()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_365() {
    if (jj_scan_token(RAB)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_385() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_43()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_233() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_251()) {
    jj_scanpos = xsp;
    if (jj_3R_252()) {
    jj_scanpos = xsp;
    if (jj_3_18()) {
    jj_scanpos = xsp;
    if (jj_3R_253()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_38() {
    if (jj_3R_43()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_385()) { jj_scanpos = xsp; break; }
      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    }
    return false;
  }

  final private boolean jj_3R_307() {
    if (jj_scan_token(LAB)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_38()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    xsp = jj_scanpos;
    if (jj_3R_365()) {
    jj_scanpos = xsp;
    if (jj_3R_366()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_17() {
    if (jj_3R_43()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_203() {
    if (jj_3R_233()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_202() {
    if (jj_3R_228()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_384() {
    if (jj_scan_token(IN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_383() {
    if (jj_scan_token(EQUALS)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_16() {
    if (jj_scan_token(NUMBER_LITERAL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(DOT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_50() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_16()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    xsp = jj_scanpos;
    if (jj_3R_202()) {
    jj_scanpos = xsp;
    lookingAhead = true;
    jj_semLA = IsNotExpression();
    lookingAhead = false;
    if (!jj_semLA || jj_3R_203()) {
    jj_scanpos = xsp;
    if (jj_3_17()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_363() {
    if (jj_scan_token(BANG)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_382()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_383()) {
    jj_scanpos = xsp;
    if (jj_3R_384()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_43()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_14() {
    if (jj_3R_43()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_364() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_363()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_15() {
    if (jj_3R_50()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_306() {
    if (jj_scan_token(LWB)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_43()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(EXCEPT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_363()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_364()) { jj_scanpos = xsp; break; }
      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    }
    if (jj_scan_token(RWB)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_228() {
    if (jj_scan_token(ASSUME)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_89() {
    if (jj_scan_token(ASSUMPTION)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_412() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_43()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_90() {
    if (jj_3R_228()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_403() {
    if (jj_scan_token(LSB)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_43()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_412()) { jj_scanpos = xsp; break; }
      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    }
    if (jj_scan_token(RSB)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_13() {
    if (jj_3R_49()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(DEF)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_88() {
    if (jj_scan_token(ASSUME)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_402() {
    if (jj_scan_token(DOT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_49()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_87() {
    if (jj_scan_token(LOCAL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_382() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_402()) {
    jj_scanpos = xsp;
    if (jj_3R_403()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_42() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_87()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    xsp = jj_scanpos;
    if (jj_3R_88()) {
    jj_scanpos = xsp;
    if (jj_3R_89()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    xsp = jj_scanpos;
    if (jj_3_13()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    xsp = jj_scanpos;
    if (jj_3R_90()) {
    jj_scanpos = xsp;
    if (jj_3_14()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_49() {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_411() {
    if (jj_3R_382()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_400() {
    if (jj_scan_token(BANG)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    if (jj_3R_411()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_411()) { jj_scanpos = xsp; break; }
      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    }
    if (jj_scan_token(EQUALS)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_43()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_232() {
    if (jj_3R_44()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_231() {
    if (jj_3R_45()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_376() {
    if (jj_3R_49()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(COLON)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_43()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_230() {
    if (jj_3R_244()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_373() {
    if (jj_3R_49()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(MAPTO)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_43()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_324() {
    if (jj_3R_325()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_381() {
    if (jj_scan_token(ARSB)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_367()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_401() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_400()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_11() {
    if (jj_scan_token(op_76)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_380() {
    if (jj_scan_token(EXCEPT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_400()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_401()) { jj_scanpos = xsp; break; }
      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    }
    if (jj_scan_token(RSB)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_12() {
    if (jj_3R_43()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_418() {
    if (jj_scan_token(op_76)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_379() {
    if (jj_scan_token(ARROW)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_43()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(RSB)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_399() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_43()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_36() {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(COLON)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_378() {
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_399()) { jj_scanpos = xsp; break; }
      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    }
    if (jj_scan_token(RSB)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_201() {
    if (jj_3R_232()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_37() {
    if (jj_3R_43()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_378()) {
    jj_scanpos = xsp;
    if (jj_3R_379()) {
    jj_scanpos = xsp;
    if (jj_3R_380()) {
    jj_scanpos = xsp;
    if (jj_3R_381()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_377() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_376()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_200() {
    if (jj_3R_231()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_199() {
    if (jj_3R_230()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_362() {
    if (jj_3R_376()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_377()) { jj_scanpos = xsp; break; }
      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    }
    if (jj_scan_token(RSB)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_375() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_373()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_198() {
    if (jj_3R_49()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_48() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_198()) {
    jj_scanpos = xsp;
    if (jj_3R_199()) {
    jj_scanpos = xsp;
    if (jj_3R_200()) {
    jj_scanpos = xsp;
    if (jj_3R_201()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(SUBSTITUTE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    xsp = jj_scanpos;
    if (jj_3R_418()) {
    jj_scanpos = xsp;
    if (jj_3_12()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_35() {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(MAPTO)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_361() {
    if (jj_3R_373()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_375()) { jj_scanpos = xsp; break; }
      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    }
    if (jj_scan_token(RSB)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_374() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_373()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_360() {
    if (jj_3R_373()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_374()) { jj_scanpos = xsp; break; }
      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    }
    if (jj_scan_token(RSB)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_372() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_347()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_10() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_48()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_359() {
    if (jj_3R_347()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_372()) { jj_scanpos = xsp; break; }
      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    }
    if (jj_scan_token(MAPTO)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_43()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(RSB)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_395() {
    if (jj_scan_token(WITH)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_48()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_10()) { jj_scanpos = xsp; break; }
      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    }
    return false;
  }

  final private boolean jj_3R_305() {
    if (jj_scan_token(LSB)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    xsp = jj_scanpos;
    lookingAhead = true;
    jj_semLA = matchFcnConst();
    lookingAhead = false;
    if (!jj_semLA || jj_3R_359()) {
    jj_scanpos = xsp;
    if (jj_3R_360()) {
    jj_scanpos = xsp;
    lookingAhead = true;
    jj_semLA = (getToken(2).kind == MAPTO) && isFieldNameToken( getToken(1));
    lookingAhead = false;
    if (!jj_semLA || jj_3R_361()) {
    jj_scanpos = xsp;
    if (jj_3R_362()) {
    jj_scanpos = xsp;
    if (jj_3_37()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_59() {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_82() {
    if (jj_scan_token(INSTANCE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_49()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_395()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_57() {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_420() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_43()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_419() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_347()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_410() {
    Token xsp;
    if (jj_3R_420()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_420()) { jj_scanpos = xsp; break; }
      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    }
    return false;
  }

  final private boolean jj_3R_81() {
    if (jj_scan_token(LOCAL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_40() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_81()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_82()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_58() {
    if (jj_3R_211()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_409() {
    if (jj_scan_token(COLON)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_347()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_419()) { jj_scanpos = xsp; break; }
      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    }
    return false;
  }

  final private boolean jj_3R_398() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_409()) {
    jj_scanpos = xsp;
    if (jj_3R_410()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_32() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_58()) {
    jj_scanpos = xsp;
    if (jj_3R_59()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(COLON)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_213() {
    if (jj_3R_49()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_397() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_347()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_33() {
    if (jj_3R_43()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_398()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_56() {
    if (jj_3R_211()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_423() {
    if (jj_3R_232()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_31() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_56()) {
    jj_scanpos = xsp;
    if (jj_3R_57()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(COMMA)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_62() {
    if (jj_3R_43()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(COLON)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_347()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_397()) { jj_scanpos = xsp; break; }
      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    }
    return false;
  }

  final private boolean jj_3R_422() {
    if (jj_3R_231()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(US)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_396() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_43()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_61() {
    if (jj_3R_43()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_396()) { jj_scanpos = xsp; break; }
      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    }
    return false;
  }

  final private boolean jj_3R_417() {
    if (jj_scan_token(US)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_422()) {
    jj_scanpos = xsp;
    if (jj_3R_423()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_416() {
    if (jj_3R_230()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(US)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_212() {
    if (jj_3R_211()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_406() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_416()) {
    jj_scanpos = xsp;
    if (jj_3R_417()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_34() {
    Token xsp;
    xsp = jj_scanpos;
    lookingAhead = true;
    jj_semLA = matchFcnConst();
    lookingAhead = false;
    if (!jj_semLA || jj_3R_60()) {
    jj_scanpos = xsp;
    if (jj_3R_61()) {
    jj_scanpos = xsp;
    if (jj_3R_62()) {
    jj_scanpos = xsp;
    if (jj_3_33()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_60() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_212()) {
    jj_scanpos = xsp;
    if (jj_3R_213()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(IN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_43()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(COLON)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_43()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_304() {
    if (jj_scan_token(LBC)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_34()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(RBC)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_421() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(US)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_356() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_49()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_415() {
    if (jj_scan_token(LBR)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(US)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_421()) { jj_scanpos = xsp; break; }
      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    }
    if (jj_scan_token(RBR)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_405() {
    if (jj_3R_49()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_415()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_353() {
    if (jj_3R_49()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_356()) { jj_scanpos = xsp; break; }
      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    }
    return false;
  }

  final private boolean jj_3R_352() {
    if (jj_3R_211()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_294() {
    if (jj_scan_token(T_FORALL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_347() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_352()) {
    jj_scanpos = xsp;
    if (jj_3R_353()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(IN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_43()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_224() {
    if (jj_3R_49()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_44()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_338() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_49()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_55() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_293() {
    if (jj_scan_token(T_EXISTS)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_273() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_293()) {
    jj_scanpos = xsp;
    if (jj_3R_294()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_49()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_338()) { jj_scanpos = xsp; break; }
      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    }
    if (jj_scan_token(COLON)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_43()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_225() {
    if (jj_3R_49()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_45()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_49()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_408() {
    if (jj_3R_406()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_393() {
    if (jj_3R_406()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_292() {
    if (jj_scan_token(FORALL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_348() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_347()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_30() {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_55()) { jj_scanpos = xsp; break; }
      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    }
    if (jj_scan_token(COLON)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_227() {
    if (jj_3R_244()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_49()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_346() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_49()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_337() {
    if (jj_3R_347()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_348()) { jj_scanpos = xsp; break; }
      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    }
    return false;
  }

  final private boolean jj_3R_407() {
    if (jj_3R_405()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_336() {
    if (jj_3R_49()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_346()) { jj_scanpos = xsp; break; }
      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    }
    return false;
  }

  final private boolean jj_3R_291() {
    if (jj_scan_token(EXISTS)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_394() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_407()) {
    jj_scanpos = xsp;
    if (jj_3R_408()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_272() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_291()) {
    jj_scanpos = xsp;
    if (jj_3R_292()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    xsp = jj_scanpos;
    if (jj_3R_336()) {
    jj_scanpos = xsp;
    if (jj_3R_337()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(COLON)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_43()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_392() {
    if (jj_3R_405()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_369() {
    if (jj_scan_token(LBR)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_392()) {
    jj_scanpos = xsp;
    if (jj_3R_393()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_394()) { jj_scanpos = xsp; break; }
      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    }
    if (jj_scan_token(RBR)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_226() {
    if (jj_3R_49()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_369()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_303() {
    if (jj_scan_token(LBR)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_43()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(RBR)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_47() {
    if (jj_scan_token(DEF)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_256() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_49()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_239() {
    if (jj_3R_49()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_256()) { jj_scanpos = xsp; break; }
      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    }
    return false;
  }

  final private boolean jj_3R_46() {
    if (jj_scan_token(LBR)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_211() {
    if (jj_scan_token(LAB)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_239()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(RAB)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_29() {
    if (jj_3R_43()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_280() {
    if (jj_scan_token(op_76)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_254() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_280()) {
    jj_scanpos = xsp;
    if (jj_3_29()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_9() {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_46()) {
    jj_scanpos = xsp;
    if (jj_3R_47()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_358() {
    if (jj_3R_82()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_80() {
    if (jj_3R_227()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(DEF)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_43()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_5() {
    if (jj_3R_43()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_8() {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_45()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_255() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_254()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_79() {
    if (jj_3R_226()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(DEF)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_5()) {
    jj_scanpos = xsp;
    if (jj_3R_358()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_238() {
    if (jj_scan_token(LBR)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_254()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_255()) { jj_scanpos = xsp; break; }
      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    }
    if (jj_scan_token(RBR)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_7() {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_44()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_78() {
    if (jj_3R_225()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(DEF)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_43()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_77() {
    if (jj_3R_224()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(DEF)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_43()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_357() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_347()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_6() {
    if (jj_scan_token(IDENTIFIER)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(LSB)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_76() {
    if (jj_3R_49()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(LSB)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_347()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_357()) { jj_scanpos = xsp; break; }
      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    }
    if (jj_scan_token(RSB)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(DEF)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_43()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_75() {
    if (jj_scan_token(LOCAL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_371() {
    if (jj_scan_token(BANG)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_300()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_370() {
    if (jj_3R_238()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_39() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_75()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(DEFBREAK)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    xsp = jj_scanpos;
    if (jj_3R_76()) {
    jj_scanpos = xsp;
    if (jj_3R_77()) {
    jj_scanpos = xsp;
    if (jj_3R_78()) {
    jj_scanpos = xsp;
    if (jj_3R_79()) {
    jj_scanpos = xsp;
    if (jj_3R_80()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_318() {
    if (jj_3R_49()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_370()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    xsp = jj_scanpos;
    if (jj_3R_371()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_223() {
    if (jj_scan_token(T_FORALL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_317() {
    if (jj_3R_232()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_316() {
    if (jj_3R_231()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_222() {
    if (jj_scan_token(T_EXISTS)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_315() {
    if (jj_3R_324()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_221() {
    if (jj_scan_token(LET)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_300() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_315()) {
    jj_scanpos = xsp;
    if (jj_3R_316()) {
    jj_scanpos = xsp;
    if (jj_3R_317()) {
    jj_scanpos = xsp;
    if (jj_3R_318()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_220() {
    if (jj_scan_token(IF)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_219() {
    if (jj_scan_token(FORALL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_28() {
    if (jj_scan_token(DOT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(NUMBER_LITERAL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_247() {
    if (jj_3R_274()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_302() {
    if (jj_scan_token(NUMBER_LITERAL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_28()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_218() {
    if (jj_scan_token(EXISTS)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_322() {
    if (jj_scan_token(TRANSITION)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_250() {
    if (jj_3R_277()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_321() {
    if (jj_scan_token(STATE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_217() {
    if (jj_scan_token(CHOOSE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_301() {
    if (jj_scan_token(STRING_LITERAL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_314() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_321()) {
    jj_scanpos = xsp;
    if (jj_3R_322()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_313() {
    if (jj_scan_token(PARAMETER)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_246() {
    if (jj_3R_273()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_312() {
    if (jj_scan_token(TEMPORAL)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_70() {
    if (jj_scan_token(OR)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_74() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_216()) {
    jj_scanpos = xsp;
    if (jj_3R_217()) {
    jj_scanpos = xsp;
    if (jj_3R_218()) {
    jj_scanpos = xsp;
    if (jj_3R_219()) {
    jj_scanpos = xsp;
    if (jj_3R_220()) {
    jj_scanpos = xsp;
    if (jj_3R_221()) {
    jj_scanpos = xsp;
    if (jj_3R_222()) {
    jj_scanpos = xsp;
    if (jj_3R_223()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_216() {
    if (jj_scan_token(CASE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_284() {
    if (jj_3R_302()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_311() {
    if (jj_scan_token(ACTION)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_249() {
    if (jj_3R_276()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_283() {
    if (jj_3R_301()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_290() {
    if (jj_3R_308()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_282() {
    if (jj_3R_300()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_310() {
    if (jj_scan_token(PREDICATE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_243() {
    if (jj_3R_260()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_259() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_282()) {
    jj_scanpos = xsp;
    if (jj_3R_283()) {
    jj_scanpos = xsp;
    if (jj_3R_284()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_287() {
    if (jj_3R_305()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_69() {
    if (jj_scan_token(AND)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_43() {
    if (jj_3R_74()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_309() {
    if (jj_scan_token(CONSTANT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_295() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_309()) {
    jj_scanpos = xsp;
    if (jj_3R_310()) {
    jj_scanpos = xsp;
    if (jj_3R_311()) {
    jj_scanpos = xsp;
    if (jj_3R_312()) {
    jj_scanpos = xsp;
    if (jj_3R_313()) {
    jj_scanpos = xsp;
    if (jj_3R_314()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_68() {
    if (jj_scan_token(BOR)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_248() {
    if (jj_3R_275()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_245() {
    if (jj_3R_272()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_323() {
    if (jj_3R_229()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_229() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_245()) {
    jj_scanpos = xsp;
    if (jj_3R_246()) {
    jj_scanpos = xsp;
    if (jj_3R_247()) {
    jj_scanpos = xsp;
    if (jj_3R_248()) {
    jj_scanpos = xsp;
    if (jj_3R_249()) {
    jj_scanpos = xsp;
    if (jj_3R_250()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_41() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_67()) {
    jj_scanpos = xsp;
    if (jj_3R_68()) {
    jj_scanpos = xsp;
    if (jj_3R_69()) {
    jj_scanpos = xsp;
    if (jj_3R_70()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_67() {
    if (jj_scan_token(BAND)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_289() {
    if (jj_3R_307()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_73() {
    if (jj_scan_token(DOT)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_49()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_286() {
    if (jj_3R_304()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_279() {
    if (jj_3R_295()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_44() {
    if (jj_3R_74()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_72() {
    if (jj_3R_215()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_242() {
    if (jj_3R_259()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_71() {
    if (jj_3R_214()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_42() {
    Token xsp;
    xsp = jj_scanpos;
    lookingAhead = true;
    jj_semLA = OperatorStack.preInEmptyTop() && BStack.aboveReference( getToken(1).beginColumn);
    lookingAhead = false;
    if (!jj_semLA || jj_3R_71()) {
    jj_scanpos = xsp;
    lookingAhead = true;
    jj_semLA = ClosedStart( getToken(1)) && boxDisc() && BStack.aboveReference( getToken(1).beginColumn);
    lookingAhead = false;
    if (!jj_semLA || jj_3R_72()) {
    jj_scanpos = xsp;
    if (jj_3R_73()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_299() {
    if (jj_scan_token(BAND)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_215() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_242()) {
    jj_scanpos = xsp;
    if (jj_3R_243()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_45() {
    Token xsp;
    if (jj_3_42()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_42()) { jj_scanpos = xsp; break; }
      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    }
    xsp = jj_scanpos;
    if (jj_3R_323()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_91() {
    if (jj_3R_229()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_43() {
    Token xsp;
    xsp = jj_scanpos;
    lookingAhead = true;
    jj_semLA = BStack.aboveReference( getToken(1).beginColumn);
    lookingAhead = false;
    if (!jj_semLA || jj_3R_91()) {
    jj_scanpos = xsp;
    if (jj_3_45()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_288() {
    if (jj_3R_306()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_285() {
    if (jj_3R_303()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_278() {
    if (jj_scan_token(VARIABLE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_260() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_285()) {
    jj_scanpos = xsp;
    if (jj_3R_286()) {
    jj_scanpos = xsp;
    if (jj_3R_287()) {
    jj_scanpos = xsp;
    if (jj_3R_288()) {
    jj_scanpos = xsp;
    if (jj_3R_289()) {
    jj_scanpos = xsp;
    if (jj_3R_290()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_298() {
    if (jj_scan_token(AND)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_210() {
    if (jj_3R_238()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_344() {
    if (jj_3R_211()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_343() {
    if (jj_3R_49()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_27() {
    if (jj_3R_54()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_4() {
    if (jj_3R_42()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_54() {
    if (jj_3R_49()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_210()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(BANG)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_3() {
    if (jj_3R_41()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_297() {
    if (jj_scan_token(OR)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_2() {
    if (jj_3R_40()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_277() {
    if (jj_scan_token(CHOOSE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_343()) {
    jj_scanpos = xsp;
    if (jj_3R_344()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_345()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(COLON)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_43()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_1() {
    if (jj_3R_39()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_296() {
    if (jj_scan_token(BOR)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_281() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_296()) {
    jj_scanpos = xsp;
    if (jj_3R_297()) {
    jj_scanpos = xsp;
    if (jj_3R_298()) {
    jj_scanpos = xsp;
    if (jj_3R_299()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_43()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_355() {
    if (jj_3R_281()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_66() {
    if (jj_scan_token(AND)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_258() {
    if (jj_3R_281()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_355()) { jj_scanpos = xsp; break; }
      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    }
    return false;
  }

  final private boolean jj_3R_64() {
    if (jj_scan_token(OR)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_354() {
    if (jj_3R_281()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_40() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_65()) {
    jj_scanpos = xsp;
    if (jj_3R_66()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_65() {
    if (jj_scan_token(BAND)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_237() {
    if (jj_scan_token(CHOOSE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_39() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_63()) {
    jj_scanpos = xsp;
    if (jj_3R_64()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_63() {
    if (jj_scan_token(BOR)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_257() {
    if (jj_3R_281()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_354()) { jj_scanpos = xsp; break; }
      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    }
    return false;
  }

  final private boolean jj_3R_241() {
    if (jj_3R_258()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_240() {
    if (jj_3R_257()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_214() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_240()) {
    jj_scanpos = xsp;
    if (jj_3R_241()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_236() {
    if (jj_scan_token(CASE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_25() {
    if (jj_scan_token(CHOOSE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_24() {
    if (jj_scan_token(CASE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_350() {
    if (jj_3R_39()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_342() {
    Token xsp;
    if (jj_3R_350()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_350()) { jj_scanpos = xsp; break; }
      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    }
    return false;
  }

  final private boolean jj_3R_209() {
    if (jj_3R_228()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_26() {
    if (jj_3R_43()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_208() {
    if (jj_3R_237()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_207() {
    if (jj_3R_236()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_53() {
    Token xsp;
    xsp = jj_scanpos;
    lookingAhead = true;
    jj_semLA = true;
    lookingAhead = false;
    if (!jj_semLA || jj_3R_207()) {
    jj_scanpos = xsp;
    lookingAhead = true;
    jj_semLA = true;
    lookingAhead = false;
    if (!jj_semLA || jj_3R_208()) {
    jj_scanpos = xsp;
    if (jj_3_26()) {
    jj_scanpos = xsp;
    if (jj_3R_209()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_276() {
    if (jj_scan_token(LET)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_342()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(LETIN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_43()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_349() {
    if (jj_scan_token(OTHER)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(ARROW)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_43()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_339() {
    if (jj_3R_43()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(ARROW)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_43()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_95() {
    if (jj_scan_token(op_70)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_94() {
    if (jj_scan_token(op_69)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_93() {
    if (jj_scan_token(op_68)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_92() {
    if (jj_scan_token(op_57)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_341() {
    if (jj_scan_token(CASESEP)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_349()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_44() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_92()) {
    jj_scanpos = xsp;
    if (jj_3R_93()) {
    jj_scanpos = xsp;
    if (jj_3R_94()) {
    jj_scanpos = xsp;
    if (jj_3R_95()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_340() {
    if (jj_scan_token(CASESEP)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_339()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_23() {
    if (jj_3R_53()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_197() {
    if (jj_scan_token(op_119)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_275() {
    if (jj_scan_token(CASE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_339()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_340()) { jj_scanpos = xsp; break; }
      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    }
    xsp = jj_scanpos;
    if (jj_3R_341()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_196() {
    if (jj_scan_token(op_118)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_195() {
    if (jj_scan_token(op_117)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_194() {
    if (jj_scan_token(op_111)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_193() {
    if (jj_scan_token(op_110)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_192() {
    if (jj_scan_token(op_109)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_234() {
    if (jj_scan_token(ProofStepLexeme)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_191() {
    if (jj_scan_token(op_108)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_190() {
    if (jj_scan_token(op_107)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_189() {
    if (jj_scan_token(op_106)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_188() {
    if (jj_scan_token(op_105)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_187() {
    if (jj_scan_token(op_104)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_186() {
    if (jj_scan_token(op_103)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_185() {
    if (jj_scan_token(op_102)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_184() {
    if (jj_scan_token(op_101)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_183() {
    if (jj_scan_token(op_100)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_274() {
    if (jj_scan_token(IF)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_43()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(THEN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_43()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(ELSE)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_43()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_182() {
    if (jj_scan_token(op_98)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_181() {
    if (jj_scan_token(op_97)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_180() {
    if (jj_scan_token(op_96)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_179() {
    if (jj_scan_token(op_95)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_178() {
    if (jj_scan_token(op_94)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_177() {
    if (jj_scan_token(op_93)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_206() {
    if (jj_scan_token(PF)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_176() {
    if (jj_scan_token(op_92)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_175() {
    if (jj_scan_token(op_91)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_174() {
    if (jj_scan_token(op_90)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_173() {
    if (jj_scan_token(op_89)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_172() {
    if (jj_scan_token(op_88)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_171() {
    if (jj_scan_token(op_87)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_170() {
    if (jj_scan_token(op_86)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_169() {
    if (jj_scan_token(op_85)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_168() {
    if (jj_scan_token(op_84)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_167() {
    if (jj_scan_token(op_83)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_166() {
    if (jj_scan_token(op_82)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_235() {
    if (jj_scan_token(LET)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_165() {
    if (jj_scan_token(op_81)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_164() {
    if (jj_scan_token(op_80)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_163() {
    if (jj_scan_token(op_79)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_162() {
    if (jj_scan_token(op_78)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_161() {
    if (jj_scan_token(op_77)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_160() {
    if (jj_scan_token(op_75)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_159() {
    if (jj_scan_token(op_74)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_158() {
    if (jj_scan_token(op_73)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_157() {
    if (jj_scan_token(op_72)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_156() {
    if (jj_scan_token(op_71)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_155() {
    if (jj_scan_token(op_67)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_154() {
    if (jj_scan_token(op_66)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_153() {
    if (jj_scan_token(EQUALS)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_152() {
    if (jj_scan_token(op_64)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_205() {
    if (jj_3R_235()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_151() {
    if (jj_scan_token(op_63)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_150() {
    if (jj_scan_token(op_62)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_149() {
    if (jj_scan_token(op_59)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_148() {
    if (jj_scan_token(op_56)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_147() {
    if (jj_scan_token(op_55)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_146() {
    if (jj_scan_token(op_54)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_145() {
    if (jj_scan_token(op_53)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_52() {
    if (jj_3R_206()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_144() {
    if (jj_scan_token(op_52)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_143() {
    if (jj_scan_token(op_51)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_142() {
    if (jj_scan_token(op_50)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_320() {
    if (jj_scan_token(SF)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_141() {
    if (jj_scan_token(op_49)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_140() {
    if (jj_scan_token(op_48)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_139() {
    if (jj_scan_token(op_47)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_138() {
    if (jj_scan_token(op_46)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_137() {
    if (jj_scan_token(op_45)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_204() {
    if (jj_3R_234()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_136() {
    if (jj_scan_token(op_44)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_135() {
    if (jj_scan_token(op_43)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_134() {
    if (jj_scan_token(op_42)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_51() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_204()) {
    jj_scanpos = xsp;
    if (jj_3R_205()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_368() {
    if (jj_scan_token(LBR)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_43()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_scan_token(RBR)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_133() {
    if (jj_scan_token(op_41)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_132() {
    if (jj_scan_token(op_40)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_131() {
    if (jj_scan_token(op_39)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_319() {
    if (jj_scan_token(WF)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_130() {
    if (jj_scan_token(op_38)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_21() {
    Token xsp;
    if (jj_3R_51()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_51()) { jj_scanpos = xsp; break; }
      if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    }
    return false;
  }

  final private boolean jj_3_22() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_21()) {
    jj_scanpos = xsp;
    if (jj_3R_52()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_308() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_319()) {
    jj_scanpos = xsp;
    if (jj_3R_320()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    } else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    if (jj_3R_367()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    xsp = jj_scanpos;
    if (jj_3R_368()) jj_scanpos = xsp;
    else if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_129() {
    if (jj_scan_token(op_37)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_128() {
    if (jj_scan_token(op_36)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_127() {
    if (jj_scan_token(op_35)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_126() {
    if (jj_scan_token(op_34)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_125() {
    if (jj_scan_token(op_33)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_124() {
    if (jj_scan_token(op_32)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_123() {
    if (jj_scan_token(op_31)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_122() {
    if (jj_scan_token(op_30)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_121() {
    if (jj_scan_token(op_27)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3_20() {
    if (jj_3R_43()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_120() {
    if (jj_scan_token(op_25)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_119() {
    if (jj_scan_token(op_24)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_118() {
    if (jj_scan_token(op_23)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_117() {
    if (jj_scan_token(op_22)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_116() {
    if (jj_scan_token(op_21)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_115() {
    if (jj_scan_token(IN)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_114() {
    if (jj_scan_token(op_19)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_391() {
    if (jj_3R_307()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_113() {
    if (jj_scan_token(op_18)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_390() {
    if (jj_3R_306()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_112() {
    if (jj_scan_token(op_17)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_389() {
    if (jj_3R_305()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_111() {
    if (jj_scan_token(op_16)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_388() {
    if (jj_3R_304()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_110() {
    if (jj_scan_token(op_15)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_387() {
    if (jj_3R_303()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_109() {
    if (jj_scan_token(op_14)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_386() {
    if (jj_3R_404()) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_108() {
    if (jj_scan_token(op_13)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  final private boolean jj_3R_85() {
    if (jj_scan_token(PROPOSITION)) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) return false;
    return false;
  }

  public TLAplusParserTokenManager token_source;
  ASCII_CharStream jj_input_stream;
  public Token token, jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  public boolean lookingAhead = false;
  private boolean jj_semLA;
  private int jj_gen;
  final private int[] jj_la1 = new int[103];
  final private int[] jj_la1_0 = {0x0,0x0,0x0,0x0,0x4,0x80000,0x80000,0x100008,0x0,0x0,0x100008,0x0,0x100008,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
  final private int[] jj_la1_1 = {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4,0x0,0x8000,0x744804ec,0x14000428,0x40000004,0x0,0x0,0x0,0x14000420,0x0,0x0,0x0,0x0,0x400000,0x0,0x80000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x400000,0x0,0x0,0x400000,0xc0,0x40,0x40,0x14000420,0x480000,0x0,0x400000,0x20000000,0x40,0x1000000,0x100000,0x8000000,0x0,0x40,0x0,0x0,0x0,0x0,0x154300,0x0,0x0,0x0,0x0,0x0,0x0,0x14000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x400000,0x0,0x0,0x0,0x154300,};
  final private int[] jj_la1_2 = {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2000,0x0,0x100748,0x648,0x0,0x2000,0x2000,0x208,0x248,0x2000,0x40000,0x0,0x10000,0x0,0x2000,0x0,0x0,0x2000,0x0,0x10000,0x2000,0x10000,0x40000,0x2000,0x40000,0x0,0x10000,0x0,0x1000,0x0,0x0,0x0,0x0,0x0,0x648,0x0,0x0,0x0,0x100,0x0,0x0,0x0,0x0,0x1,0x0,0x4004,0x40000,0x15240802,0x15240802,0x30,0x0,0x40000,0x80000000,0x0,0x2000,0x0,0x0,0x2000,0x2000,0x10000000,0x30,0x2000,0x2000,0x10000000,0x10000000,0x2000,0x2000,0x2000,0x2000,0x6000,0x6000,0x2000,0x2000,0x2000,0x2000,0x2000,0x2000,0xc02000,0x208000,0x2000,0x208000,0x2000,0x0,0x2000,0x60000000,0x40000,0x80000000,0x15240000,0x802,0x40000,0x100000,0x0,0x10000000,0x8000,0x30,};
  final private int[] jj_la1_3 = {0x3ff000,0x3ff800,0xffc00000,0x780,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffc00780,0x3ff800,0x0,0x0,0x0,0x3ff800,0x0,0x0,0x3ff800,0x0,0x3ff800,0x0,0x0,0x0,0xffc00780,0x3ff800,0x0,0x0,0xffffff80,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xfffff798,0x0,0xfffff798,0x0,0x0,0xfffff780,0x0,0x800,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4800060,0x0,0x0,0x0,};
  final private int[] jj_la1_4 = {0x0,0x0,0xffffffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffffffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffffffff,0x0,0x0,0x0,0xffffffff,0x0,0x0,0x0,0x0,0x0,0x0,0x200,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffffffff,0x0,0xffffffff,0x0,0x0,0xffffffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x200,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
  final private int[] jj_la1_5 = {0x0,0x0,0xffffffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffffffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffffffff,0x0,0x0,0x0,0xffffffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xffffffff,0x0,0xffffffff,0x0,0x0,0xffffffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
  final private int[] jj_la1_6 = {0x0,0x0,0xfffffff,0x0,0x0,0x10000000,0x10000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xfffffff,0x10000000,0x0,0x0,0x0,0x0,0x0,0x10000000,0x10000000,0x0,0x10000000,0x0,0x0,0x0,0xfffffff,0x0,0x0,0x0,0x1fffffff,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40000000,0x0,0x0,0x0,0x0,0x0,0x0,0x1fffffff,0x0,0x1fffffff,0x0,0x0,0x1fffffff,0x0,0x0,0x0,0x0,0x0,0x10000000,0x0,0x0,0x0,0x10000000,0x10000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10000000,0x0,0x0,0x0,0x0,0x10000000,0x0,0x0,};
  final private JJCalls[] jj_2_rtns = new JJCalls[45];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  public TLAplusParser(java.io.InputStream stream) {
    jj_input_stream = new ASCII_CharStream(stream, 1, 1);
    token_source = new TLAplusParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 103; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(java.io.InputStream stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 103; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public TLAplusParser(java.io.Reader stream) {
    jj_input_stream = new ASCII_CharStream(stream, 1, 1);
    token_source = new TLAplusParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 103; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 103; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public TLAplusParser(TLAplusParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 103; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(TLAplusParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 103; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  final private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    return (jj_scanpos.kind != kind);
  }

  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  final public Token getToken(int index) {
    Token t = lookingAhead ? jj_scanpos : token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.Vector jj_expentries = new java.util.Vector();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      boolean exists = false;
      for (java.util.Enumeration enum = jj_expentries.elements(); enum.hasMoreElements();) {
        int[] oldentry = (int[])(enum.nextElement());
        if (oldentry.length == jj_expentry.length) {
          exists = true;
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              exists = false;
              break;
            }
          }
          if (exists) break;
        }
      }
      if (!exists) jj_expentries.addElement(jj_expentry);
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  final public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[223];
    for (int i = 0; i < 223; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 103; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
          if ((jj_la1_3[i] & (1<<j)) != 0) {
            la1tokens[96+j] = true;
          }
          if ((jj_la1_4[i] & (1<<j)) != 0) {
            la1tokens[128+j] = true;
          }
          if ((jj_la1_5[i] & (1<<j)) != 0) {
            la1tokens[160+j] = true;
          }
          if ((jj_la1_6[i] & (1<<j)) != 0) {
            la1tokens[192+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 223; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  final public void enable_tracing() {
  }

  final public void disable_tracing() {
  }

  final private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 45; i++) {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
            case 4: jj_3_5(); break;
            case 5: jj_3_6(); break;
            case 6: jj_3_7(); break;
            case 7: jj_3_8(); break;
            case 8: jj_3_9(); break;
            case 9: jj_3_10(); break;
            case 10: jj_3_11(); break;
            case 11: jj_3_12(); break;
            case 12: jj_3_13(); break;
            case 13: jj_3_14(); break;
            case 14: jj_3_15(); break;
            case 15: jj_3_16(); break;
            case 16: jj_3_17(); break;
            case 17: jj_3_18(); break;
            case 18: jj_3_19(); break;
            case 19: jj_3_20(); break;
            case 20: jj_3_21(); break;
            case 21: jj_3_22(); break;
            case 22: jj_3_23(); break;
            case 23: jj_3_24(); break;
            case 24: jj_3_25(); break;
            case 25: jj_3_26(); break;
            case 26: jj_3_27(); break;
            case 27: jj_3_28(); break;
            case 28: jj_3_29(); break;
            case 29: jj_3_30(); break;
            case 30: jj_3_31(); break;
            case 31: jj_3_32(); break;
            case 32: jj_3_33(); break;
            case 33: jj_3_34(); break;
            case 34: jj_3_35(); break;
            case 35: jj_3_36(); break;
            case 36: jj_3_37(); break;
            case 37: jj_3_38(); break;
            case 38: jj_3_39(); break;
            case 39: jj_3_40(); break;
            case 40: jj_3_41(); break;
            case 41: jj_3_42(); break;
            case 42: jj_3_43(); break;
            case 43: jj_3_44(); break;
            case 44: jj_3_45(); break;
          }
        }
        p = p.next;
      } while (p != null);
    }
    jj_rescan = false;
  }

  final private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
